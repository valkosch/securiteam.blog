<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Posts on Kurcz Valentin</title>
        <link>http://localhost:1313/posts/</link>
        <description>Recent content in Posts on Kurcz Valentin</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>en</language>
        <copyright>&lt;a href=&#34;https://creativecommons.org/licenses/by-nc/4.0/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;CC BY-NC 4.0&lt;/a&gt;</copyright>
        <lastBuildDate>Wed, 17 Jul 2024 17:53:55 +0200</lastBuildDate>
        <atom:link href="http://localhost:1313/posts/index.xml" rel="self" type="application/rss+xml" />
        
        <item>
            <title>Reverse engineering - No. 1</title>
            <link>http://localhost:1313/posts/2024/07/reverse-engineering-no.-1/</link>
            <pubDate>Wed, 17 Jul 2024 17:53:55 +0200</pubDate>
            
            <guid>http://localhost:1313/posts/2024/07/reverse-engineering-no.-1/</guid>
            <description>Introduction to the world of reverse engineering, where I solve beginner-level program reverse engineering tasks, demonstrate techniques and basics. All I can say is: &amp;ldquo;Abandon all hope, ye who enter here.&amp;rdquo;</description>
            <content type="html"><![CDATA[<h2 id="introduction">Introduction</h2>
<p>In IT, it can be very useful to see behind the scenes. For example, when a company is attacked with a malicious software, on the blue team side we want to understand the enemy&rsquo;s techniques, tactics, and procedures to effectively defend ourselves. In this case, we need to break down the mentioned program. On the other hand, sometimes we are on the red team, driven by completely noble intentions and with permission, trying to find a flaw in a program so we can exploit it to achieve our goals.</p>
<p>The importance of the skills that can be learned through program reverse engineering cannot be overstated in IT. Cybersecurity is undoubtedly a field where this is especially true. It&rsquo;s no coincidence that American three-letter agencies invest billions of dollars into this sector.</p>
<p>In this short article series, I will reverse engineer a few &ldquo;crackmes&rdquo; using the simplest tools possible. The programs are from the <a href="https://crackmes.one">crackmes.one</a> site, where people can upload programs for educational purposes, and others can crack them for practice.</p>
<p><img alt="crackmes" src="/crackmes.png"></p>
<h2 id="foundation">Foundation</h2>
<p>Why is that, it&rsquo;s so incredibly difficult to reverse engineer programs? There are several economic models for software development in the world, but we usually say that a program is either closed or open source.</p>
<p>Closed source, proprietary programs are usually funded and developed by companies, and then the final product is sold. The source code is not published because that would make the program free.</p>
<p>In contrast, open source programs, like the Linux kernel, are maintained by the community, are free, and anyone can contribute and commit to them.</p>
<p>I won&rsquo;t delve into this debate now, both sides have their arguments, pros and cons, but I will say that from a security perspective, open source projects are in a better position than the other side. The reason is simple, closed source code cannot be verified without reverse engineering. The whole system works on the &ldquo;trust me bro&rdquo; principle, as the user has no power to see what the program actually does. This is problematic because it means trusting that the developers have done a perfect job and that the program doesn&rsquo;t do anything beyond what it claims. We&rsquo;ve seen what happens when this trust is misplaced (e.g., Facebook lawsuit).</p>
<p>So now we will deal with programs written in C/C++ where the source code is not provided, only an executable file. This executable consists of machine code because the human-readable code is translated by the compiler into the computer&rsquo;s language. Unless we explicitly tell the compiler to keep the symbols, this translation will be irreversible, code-wise. In short, we won&rsquo;t be able to read the source code. However, there are advanced &ldquo;decompilers&rdquo; like <a href="https://github.com/NationalSecurityAgency/ghidra">Ghidra</a> that can roughly guess what was the original source code, but we probably won&rsquo;t need those now.</p>
<p>I will solve relatively simple and beginner tasks, but to fully understand the solutions, knowledge of C/C++ and Intel x86-64 assembly is essential and recommended.</p>
<p>I will use the following CLI programs:</p>
<ul>
<li><strong>objdump</strong> - allows us to read the assembly code of the program</li>
<li><strong>ltrace</strong> and <strong>strace</strong> - trace dynamic library calls during the program&rsquo;s execution (e.g., printf or strcmp)</li>
<li><strong>gdb</strong> - a Swiss army knife for every programmer, a debugger software, but also great tool for reverse engineering</li>
<li><strong>strings</strong> - a simple tool that prints all printable characters found in the file</li>
</ul>
<p>An important precaution before we dive in: it&rsquo;s advisable to do these crackmes on a virtual machine since we are about to run an unknown program, even though the exes are checked after upload by the crackme moderators. The virtual environment separates this program from our real system, making it safer. However, keep in mind that even this is not completely foolproof, as if there is, for example, a shared folder in the virtual machine, there is already a bridge between the two systems. Also, there are known malwares that can escape the virtual machine under certain conditions. Nonetheless, none of these probably threaten us, but this precaution and this &ldquo;adversary mindset&rdquo;—preparing for the worst—is a useful routine when working in cybersecurity.</p>
<h2 id="reverse-engineering">Reverse Engineering</h2>
<p>For the virtual machine, I use <a href="https://www.virtualbox.org/">VirtualBox</a> with a bare-bones Arch Linux and the listed tools.</p>
<h3 id="first">First:</h3>
<h4 id="d4rkfl0ws-easy_firstcrackme-by-d4rk_fl0whttpscrackmesonecrackme5c8e1a9533c5d4776a837ecf"><a href="https://crackmes.one/crackme/5c8e1a9533c5d4776a837ecf">D4RKFL0W&rsquo;s Easy_firstCrackme-by-D4RK_FL0W</a></h4>
<p>Download it and run it just to see what we&rsquo;re dealing with.</p>
<p><img alt="fut" src="/crackmes2.png"></p>
<p>As you can see, we need to guess or bypass a password, and the password is not &ldquo;almafa&rdquo; :(.</p>
<p>Let&rsquo;s try our tools on it:</p>
<p>First, let&rsquo;s look at ltrace. Not much luck here, nothing interesting shows up, just the process of printing out to stdcout. If, for example, the program used strcmp() to check the password, we would have seen it here.</p>
<p><img alt="ltrace" src="/crackmes3.png"></p>
<p>Objdump proved to be much more useful. We look for the main block since the password check likely happens there. Here we see a small pattern that I&rsquo;ve highlighted. The program checks the entered password character by character with the cmp operator. The &ldquo;je&rdquo; instruction corresponds to &ldquo;jump if equal.&rdquo; So if the character is equal in cmp to the given hexadecimal value, the program skips the call that calls some &ldquo;failed&rdquo; method. Translating the hexadecimal values used in the comparison to ASCII characters and concatenating them gives us the desired password: H1DD3N. Yay!</p>
<p><img alt="objdump" src="/reverse_help.png"></p>
<p>I should note that it&rsquo;s never a good idea to check a password character by character anywhere. If it&rsquo;s necessary, ensure that the check is of constant time; otherwise, the program will be vulnerable to side-channel attacks. For example, if there is a 4-digit PIN terminal that immediately returns &ldquo;Wrong password!&rdquo; after entering the first digit, brute force will only require 40 attempts instead of 10,000.</p>
<h3 id="second">Second:</h3>
<h4 id="d4rkfl0ws-crackme2-be-d4rk_fl0whttpscrackmesonecrackme5c95646333c5d46ecd37c960"><a href="https://crackmes.one/crackme/5c95646333c5d46ecd37c960">D4RKFL0W&rsquo;s crackme2-be-D4RK_FL0W</a></h4>
<p>This one doesn&rsquo;t seem much harder at first glance; we need to figure out a password here as well.</p>
<p>Strings, ltrace, strace are not very useful here either. Looking at objdump, I didn&rsquo;t find anything that led to a trivial solution, but I saw a block in the program called _Z14check_passwordPc, which might be interesting for us. However, it was not possible to read the password from the assembly code passively like before, likely because the game maker deliberately designed it so that the program concatenates the password character by character in some hidden part using strcat() or something like that, at runtime.</p>
<p>So we need to step through the program while it runs. I will use <strong>gdb</strong> for this. Gdb is a bit bare-bones on its own, so I recommend tuning it with <a href="https://github.com/hugsy/gef">GEF</a> to make it easier to crack your neighbor&rsquo;s Wi-Fi (just kidding).</p>
<p>So what I did here:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>gbd -q crackme2-be-D4RK_FL0W
</span></span></code></pre></div><p>Start gdb.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>set disassembly-flavor Intel
</span></span><span style="display:flex;"><span>break *_Z14check_passwordPc
</span></span><span style="display:flex;"><span>run 
</span></span></code></pre></div><p>I don&rsquo;t remember what the default disassembly-flavor is, but I prefer the Intel syntax, so I set it to that. Then I placed a breakpoint at the mentioned function to stop the program&rsquo;s execution there so we can examine it more closely. The run command starts the program.</p>
<p><img alt="gdb1" src="/crackmes4.png"></p>
<p>This is the interface that greets us. To sum up, what we can see:</p>
<ul>
<li>At the top are all 16 64-bit registers the computer works with (actually, the computer works with many more registers to execute as much parallelization as possible, but the architecture instruction set is designed for 16 registers, and deviating from this would break backward compatibility, meaning old programs wouldn&rsquo;t work, so the processor internally maps these 16 registers to its many, probably thousands, of available registers).</li>
<li>Below that is the stack</li>
<li>And below that are the assembly instructions, with the next instruction highlighted in green</li>
</ul>
<p>The rest is not so interesting for us now.</p>
<p>The r8 register looks promicing: &ldquo;isAAthisFunBBCCD&rdquo;. We potentially have our winner, but let&rsquo;s investigate further. When dealing with something like this, if something is too good to be true, it probably is. I say this because these tasks often include &ldquo;honeypots,&rdquo; which are easily obtainable bait to mislead people. There is practical use for this in real life scenarios, where honeypots are placed to waste the attacker&rsquo;s resources and time. Sometimes they even act as alerts, notifying defenders when someone starts attacking the honeypot, giving them more time to prepare for defense.</p>
<p>Back to the task, let&rsquo;s step through the program using the <strong>stepi</strong> and <strong>nexti</strong> commands in gdb. The former steps into method calls, while the latter skips them.</p>
<p><img alt="gdb2" src="/crackmes5.png"></p>
<p>As you can see it here, our guess about the solution, is correct since during the execution of the program&hellip;</p>
<ol>
<li>the <strong>rax</strong> register will be equal to 0x69(&ldquo;i&rdquo;)</li>
<li>the <strong>rdx</strong> register will be equal to 0x74(&ldquo;t&rdquo;)</li>
<li>then these will be compared with the <strong>cmp dl, al</strong> instruction</li>
</ol>
<p>Therefore character by character comparison is happening here too, where my given password &ldquo;test&rdquo; is checked against the &ldquo;isAAthisFunBBCCD&rdquo; password. That&rsquo;s the solution.&quot;</p>
<p>That was is for this small introduction to binary exploitation and reverse engineering. If assembly looks a bit scary at first glance, don&rsquo;t worry you are not alone, but with time and practice you can master it, just like everything else, and I can assure you that it&rsquo;s going to worth it, especially when you are into reverse engineering.</p>
]]></content>
        </item>
        
        <item>
            <title>The consequences of the Information Revolution and the Internet</title>
            <link>http://localhost:1313/posts/2024/07/the-consequences-of-the-information-revolution-and-the-internet/</link>
            <pubDate>Tue, 09 Jul 2024 17:47:21 +0200</pubDate>
            
            <guid>http://localhost:1313/posts/2024/07/the-consequences-of-the-information-revolution-and-the-internet/</guid>
            <description>The internet is one of the sharpest double-edged swords in our world. Its positive impact on commerce and, consequently, the economy is unquestionable. However, it remains a question of what price society and people have paid for this.</description>
            <content type="html"><![CDATA[<p>Information is a central element of human behavior. It is deeply coded in us to search for, constantly collect, accumulate, process, and transmit information, as this meant survival thousands of years ago. Information is like oxygen for us. It&rsquo;s no coincidence that sensory deprivation was a highly effective method of torture because our brain needs new information; otherwise, we might fall into a state of madness. We can only talk about society because we overcame an evolutionary obstacle when we started sharing information collectively. Each generation did not have to reinvent the wheel; it was enough to learn from the elders. The internet is not much more than this; we are just the cavemen of the modern age.</p>
<h2 id="the-good">The Good</h2>
<p>There is no distance on the internet, and soon, every household will have an internet-capable device, meaning we can connect with almost anyone instantly, without physical boundaries. The amount of knowledge available is astronomical, so learning and development, in theory, have never been easier. Not to mention the number of jobs it has created and the platform it provides for commerce. <em>But where&rsquo;s the catch?</em></p>
<h2 id="the-bad">The Bad</h2>
<p>It can be said for many tools that it can be very useful until they are used with ill intentions. Take a knife, for example; you can slice bread with it, but you can also kill someone. Nuclear fission can produce clean, large amounts of energy in power plants, but it can also obliterate cities. It’s clear from these examples that most tools can cause as much harm as they can provide benefit. The internet is similar, but a bit different. The internet is not just black and white; it has many hidden consequences, the outcomes of which we cannot predict, but we can already feel their impact in our present. People do not notice these processes because they are not like an atomic flash or a cut; they feel normal because such deep-rooted instincts are exploited on the internet that most people may not even be aware of. We have lost a war we didn’t even know existed.</p>
<p>For every person, reality is what they see, hear, touch, smell, and taste, i.e., the information that reaches us daily. The modern person&rsquo;s primary source of information is the internet, so we can rightly say that the internet greatly influences our sense of reality and worldview. But what kind of reality is this?</p>
<h3 id="impact-on-human-relationships">Impact on Human Relationships</h3>
<p>Earlier, I mentioned that one of the things the internet can be proud of is bringing people together. Social media became so huge precisely because people need this; we are social beings. Various hormones, like oxytocin or dopamine, are released when we meet new people, giving us a sense of achievement. These will be discussed later. However, this has several flaws.</p>
<p>The first thing I want to highlight is that no one shares the reality of themselves on social media. Everyone shows their alter ego who is happy, earns a lot of money, travels, and generally only experiences positive moments. Now, when an average person sees this and compares it to their mediocre life, which indeed has sad and painful moments, they will be disheartened because they will think they are doing something wrong. But we can be sure that the person on the other side of the screen also has problems. This was a very general example, but we can see more if we think about bodybuilder influencers who set standards that are naturally unattainable, leading people to false ideals and possibly self-image and body image issues.</p>
<p>Our value system and moral compass is also obviously influenced by social media, as everything we do and share there is rewarded with likes and other people&rsquo;s recognition, which also gives us a sense of success. Constantly chasing this feeling leads to a value system where there is no value, as everything is <em>&ldquo;good&rdquo;</em> that brings views and likes. This is embodied by influencers who claim and do anything for money and views. In their eyes, reality is whatever brings money to the table. <em>&ldquo;Oceania has always been at war with Eurasia&rdquo;</em> said an influencer for 3 pence.</p>
<p>Despite bringing so many new people together, overall, I think it can be said that people have become lonelier because of the internet. Friends made online maintain the illusion that hundreds surround you, but in reality, you have no shared memories with any of them, and those are the truly important things. Friendships and relationships flourish when there is what we call a proof-of-work, meaning the more effort and energy you invest to create shared moments in reality.</p>
<p>Unfortunately, the word &ldquo;illusion&rdquo; comes up more and more often regarding the internet. This is because there are many things on the internet that trigger the same feelings and hormones in us as if we were doing them in reality, but they are much more secondary and artificial activities. I probably don&rsquo;t need to mention that porn also belongs here. It completely deceives and reprograms people&rsquo;s brains. Zero energy investment for infinite pleasure. This is the cancer of modern man. This eventually leads to people becoming indifferent, ambitionless, and unmotivated in every area of life because the body can no longer reward them since they have exhausted their hormone balance with the mentioned pleasures. Nothing matters, nothing brings joy because the internet has burned out the brain. This is hedonism.</p>
<p>Cyberbullying and online grooming are also significant problems, mainly arising from human character flaws, but the internet as a medium also has its share of responsibility in this.</p>
<p>I&rsquo;ve left what I think is the most painful point for last. One would think that the internet creates dialogue, sparks debates, as it brings together so many people with different thoughts, backgrounds, and financial situations that friction is inevitable. However, the situation is very different. The problem starts with profit-oriented companies, unsurprisingly, wanting to maximize profit (wow), and they do this by maximizing the time you spend on their app. One way to achieve this is by showing you content that interests you, but primarily what you <strong>like</strong>. The learning algorithms working in the background are so perfect and operate so smoothly that it quickly becomes clear to them what categories you can be classified into. You won&rsquo;t see opinions that contradict yours. If you&rsquo;re a dog person, you&rsquo;ll see dogs. There is no dialogue, no debate, no progress. What follows from this? A hyper-sterilized world is built within you where everyone agrees with you. But this is not reality. In reality, there are indeed many different opinions and thoughts that need to clash. A principle, a theory is worth something if it is put to the test. In the end, the principles that remain are the strongest, most well-founded, and most justified. What happens when this is absent, like on the internet? Theories that would have no chance in reality catch fire, such as Flat Earth believers or other pseudoscientific groups. Bubbles form on the internet with no passage between them; you state your opinion and only hear your own echo. Thus, as much as the internet connects us, it also creates chasms between us. We don&rsquo;t have to look far for the consequences: after the 2020 US elections, a civil war-like situation developed because the losing Republican party&rsquo;s followers accused the liberals of fraud. This is also not surprising, just think about the situation of a Republican voter, who was only in Republican groups on Facebook, only saw the ads of their supported candidates, etc. After that, a candidate from a party that did not even exist in their world won the election.</p>
<p>It is also worth examining all this on an individual level, as it affects us as individuals more. I think this &ldquo;for you&rdquo; marketing trick has a negative impact on people&rsquo;s personalities because people socialize into the idea that everything is about them, everything is for them. <em>&ldquo;This product is just for you!&rdquo;</em> I don&rsquo;t need to say that this can cause a rather egocentric character, which has a hysterical outrage the moment someone else has a different opinion. So far, when I said &ldquo;opinion,&rdquo; I always meant cultural and respectful opinions, but what about vulgar trolling and abuse that is also rampant on the internet. The best solution would be if people learned to behave empathetically towards each other and to express their opinions in a normal form. However, I think it is unacceptable to simply censor hurtful comments. This does not solve the problem, it just sweeps it under the rug to maintain the illusion. Who then decides what is a hurtful comment, the government? Maybe not today, but tomorrow the term &ldquo;sliced bread&rdquo; could be considered offensive just because it suits someone&rsquo;s interests. People need to develop immunity, tolerance against negative experiences, because unfortunately, reality is full of them. Meanwhile, we should strive to eliminate the ignorance that caused the trolling attitude. Homelessness will not end just by banning homeless people. The lesson is that we should always get information from multiple sources and strive to understand each other, even if we think we are right, because the world is not black and white, and we can achieve much more together, as lone heroes do not exist.</p>
<p><img alt="Öngyilkosságok száma" src="/suiciderates.png"></p>
<p>This image shows the number of suicides per 100,000 people in the United States over the years. Of course, no direct conclusion can be drawn from the data and the mentioned internet problems, as many other factors play a role, but it is still a rather depressing curve.</p>
<h3 id="impact-on-cognitive-abilities">Impact on Cognitive Abilities</h3>
<p>I also mentioned as a beneficial aspect the vast amount of knowledge available to us due to the internet. This is true, but getting information from the internet is like drinking from a fire hydrant. Our brain simply cannot absorb this much information in a healthy manner, and there are consequences.</p>
<p>First and foremost, it&rsquo;s important to recognize that as easy as it is to spread truth, it is just as easy to spread misinformation on the internet. Societies and groups can be deceived, manipulated, and toppled with it. Most people perceive reality through the internet and news portals, making manipulation and deception child&rsquo;s play. Just neet to repeat enought times that the grass is blue and the sky is green, and create your own sources, and over shout opposing views. The internet is the perfect tool for spreading propaganda, reaching everyone, not resource-intensive, people willingly watch it, and with the right algorithms, critical voices can be isolated from the believers, the hardcore followers. Luckily, no one on the internet intends to manipulate the masses :D.</p>
<p>The impact of the internet on our brain is perhaps best observed in younger generations, as most neural pathways are formed at a young age, making the brain most adaptable during this period. The problem mainly lies with the quantity and form of information.</p>
<p>In terms of quantity, it&rsquo;s important to know that the size of the internet doubles every two years and grows exponentially. When this flood of information and stimuli reaches us, our brain defends itself by simply not absorbing it. You read or watch something, but after 30 minutes, you don&rsquo;t even remember it; otherwise, the brain would be overwhelmed by the flood of stimuli. Furthermore, the vast amount of information divides our attention; we will never be able to concentrate on one thing. We start everything but finish nothing because our brain is already wokring on the next piece of information. This is a sure way for our knowledge to be superficial and useless. We have the entire knowledge of humanity at our disposal, but we can&rsquo;t do anything with it.</p>
<p>Information comes in many forms, but what I think is worth examining now, is short content. As mentioned before, acquiring information is like a drug for us. Short content perfectly fits into our increasingly fast-paced world, as it requires little time and we enjoy consuming it. We want more and more until our brain&rsquo;s receptors are fried from the many stimuli. Moreover, we see things that we like and in inexhaustible quantities. I am convinced that most of these applications (like TikTok, Instagram, Facebook) have more psychologists working behind them than programmers, as they captivate our attention in an impressive way by exploiting our various instincts. Because the ultimate goal is to get as much out of us as possible, as we are the products, our attention and data are sold. If you don&rsquo;t pay for the product, you are the product. This is not our fault; the decision is no longer made consciously by most people but reflexively, for example, reaching for the phone. However, we are very much at fault if we do not protect our children from this once we are aware of the consequences. Unfortunately, the &ldquo;iPad kid&rdquo; phenomenon is becoming more and more common, where the parent, out of fatigue or other irresponsible reasons, negligently occupies the child by handing them a tablet. Surely nothing can go wrong if a small child has unlimited access to the entire internet&hellip;</p>
<p>To mention specifics, attention span drastically decreases after prolonged consumption of short content. Our brain always adapts to circumstances, and if we always consume content that is a maximum of 1 minute long, the brain simply reprograms itself, and reading a book will no longer hold our attention. Not only do we miss out on books, but also on anything that requires even a slightly longer thought process. Speaking of books, it is also worth noting that an increasing portion of content consumed on the internet is visual. This is perhaps disadvantageous because our creativity never has to be engaged to imagine something since it is already presented to us.</p>
<h2 id="and-the-ugly">And the Ugly</h2>
<p>No matter how wonderful and utopian the internet was as a concept, at this moment, it is about exploiting and milking the masses dry, where people no longer create any real value, only consume. Everything starts when you wake up from your dream. It is time to wake up, wake up from the dream, from the comfort, and face reality, which may be ugly or hopeless, yellow and bitter, but at least it is ours. Use the internet, but don&rsquo;t let the internet use you.</p>
<p>I hope I managed to summarize my thoughts on this topic well. If you have any comments, don&rsquo;t hold back! Have a nice day!</p>
]]></content>
        </item>
        
        <item>
            <title>Locality-Aware programming</title>
            <link>http://localhost:1313/posts/2024/07/locality-aware-programming/</link>
            <pubDate>Mon, 08 Jul 2024 09:45:20 +0200</pubDate>
            
            <guid>http://localhost:1313/posts/2024/07/locality-aware-programming/</guid>
            <description>It is crucial how we traverse a matrix, whether column-wise, row-wise, or randomly. This article explores how to leverage our knowledge about computers for the benefit of our programs.</description>
            <content type="html"><![CDATA[<p>Since the Neumann architecture, during the operation of a computer, the instructions and the contents of the addresses referenced by these instructions are stored in memory. The data used in the program can be accessed from so-called data memory, which is organized into a memory hierarchy.</p>
<h2 id="memory-hierarchy">Memory Hierarchy</h2>
<p>A computer&rsquo;s performance essentially consists of the clock speed of the processor and the memory, with memory often lagging behind the processor. This means that despite having a high CPU clock speed, if the memory acts as a bottleneck, the processor has to wait for the data it needs, leading to suboptimal performance.</p>
<h3 id="principles-of-locality">Principles of Locality</h3>
<p>Fortunately, most computer programs follow certain patterns when accessing memory, known as <strong>principles of locality</strong>, which we can exploit to improve performance. There are several principles of locality:</p>
<p>If we perform an operation on a data item in memory</p>
<ul>
<li><em><strong>Temporal Locality:</strong></em> &hellip;, we will likely use it again soon. Example: incrementing a loop counter in each iteration.</li>
<li><em><strong>Spatial Locality:</strong></em>&hellip;, we are likely to use the items nearby as well. Example: traversing an array.</li>
<li><em><strong>Algorithmic Locality:</strong></em> Programs often work with dynamic data structures like binary trees or linked lists which do not fit into spatial or temporal locality but still exhibit predictable behaviors that can be exploited.</li>
</ul>
<p>By placing frequently used data and their surroundings close to the processor, we can reduce the number of slow and expensive memory operations. We still store our data in a memory but in a much faster but smaller and higher consumption memory known as cache memory. But what technology is used for cache?</p>
<p>We know several memory technologies, such as the high-density but slower and cheaper DRAM, and the low-density but faster and more expensive SRAM. To stor 1 bit, DRAM uses one transistor, while SRAM uses six, explaining the differences in power consumption, density, and cost. It is impossible to achieve cheap, fast, and large memory simultaneously, so compromises are inevitable. This leads to the concept of memory hierarchy, where the memory is structured in multiple levels, with the most frequently used memory being faster and smaller.</p>
<p><img alt="tárhierarchia" src="/tarhierarchia.png"></p>
<p>The slowest storage, the HDD or SSD, holds the least frequently used but large amounts of data. Frequently used data are stored in the random-access memory, usually DRAM, and the data used by the currently running program or process (e.g., a local variable) is stored in the cache, made of SRAM.</p>
<blockquote>
<p>I will not go into the subtle details of how a cache works here, however if you are interested, it worths looking into how prefetching works, because that&rsquo;s how the computer loads data into the cache before it&rsquo;s used, after making an educated guess.</p>
</blockquote>
<p>To ensure efficient processor utilization, the programmer should aid the memory hierarchy:</p>
<ul>
<li>If the programmer references memory randomly in the cache, many cache misses occur, forcing the computer to resort to the slow main memory.</li>
<li>In DRAM-based system memory, accessing cells in the same row is fast, but random access to different rows incurs expensive and slow operations, due to the time cost of opening new rows.</li>
</ul>
<p><strong>The programmer&rsquo;s goal is to address memory in a way that aligns with the principles of locality. How?</strong></p>
<h2 id="locality-friendly-loop-organization">Locality-Friendly Loop Organization</h2>
<p>In practice, we often need to traverse one- or multidimensional arrays, requiring loops. I will show you examples of loop organization techniques that utilize our memory hierarchy knowledge to improve our program&rsquo;s runtime.</p>
<h3 id="merging-loops">Merging loops</h3>
<p>Original code:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> N; i<span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>    b[i] <span style="color:#f92672">=</span> c <span style="color:#f92672">*</span> a[i] <span style="color:#f92672">-</span> x;
</span></span><span style="display:flex;"><span>sum <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> N; i<span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>    sum <span style="color:#f92672">+=</span> b[i];
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span>( <span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> N; i<span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>    d[i] <span style="color:#f92672">=</span> a[i] <span style="color:#f92672">+</span> b[i];
</span></span></code></pre></div><p>The above is a simple C code example. Now, let&rsquo;s calculate the cache miss ratio, which will tell how often do we need to access the slow memory because the data is not in the cache. Let&rsquo;s assume the following for simplicity:</p>
<ul>
<li>N is arbitrarily large</li>
<li>The cache block size is 64 bytes</li>
<li>Array elements are 8-byte doubles</li>
<li>Accessing i, c, x, and sum does not involve memory access.</li>
</ul>
<p>The first for loop traverses arrays a and b. At i=0, there is a cache miss for a[0] and b[0], as the cache is initially empty. A cache miss loads 8 array elements into the cache, so there will be a cache miss every 8 steps, leading to 2N/8 cache misses for 2N memory references.</p>
<p>In the second for loop, if N is large enough, the beginning of array b is no longer in the cache, so there will be a cache miss every 8 steps again, resulting in N/8 cache misses.</p>
<p>Similarly, the third loop will have 3N/8 cache misses for 3N memory references.</p>
<p>Summing the cache misses, we get 6N memory references with a 12.5% cache miss ratio.</p>
<p>Now, using loop merging:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span>sum <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>; i<span style="color:#f92672">&lt;</span>N; i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>    b[i] <span style="color:#f92672">=</span> c <span style="color:#f92672">*</span> a[i] <span style="color:#f92672">+</span> x;
</span></span><span style="display:flex;"><span>    sum <span style="color:#f92672">+=</span> b[i];
</span></span><span style="display:flex;"><span>    d[i] <span style="color:#f92672">=</span> a[i] <span style="color:#f92672">+</span> b[i];
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>This algorithm has the same functionality as the original but is more efficient. The first two memory references in the loop body still cause cache misses every 8 steps, but subsequent accesses to a[i] and b[i] will not cause cache misses as they are already in the cache. The third line will only cause a cache miss for d[i] every 8 steps.</p>
<p>Thus, we have 3N/8 cache misses, reducing the cache miss ratio to 6.25%, half of the original.</p>
<p>The first rule of thumb is to merge loops wherever we can.</p>
<h3 id="loop-order-optimization">Loop Order Optimization</h3>
<p>Consider the following example where the order of loops in traversing a 2D array affects performance.</p>
<p>First, the optimal example:</p>
<p>Row-major traversal:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>; i<span style="color:#f92672">&lt;</span>N; i<span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> j<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>; j<span style="color:#f92672">&lt;</span>N; j<span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>        sum <span style="color:#f92672">+=</span> a[i][j];
</span></span></code></pre></div><p>Before analyzing cache misses, it&rsquo;s important to note that C stores 2D arrays in row-major order. Thus, a 2D array {{4, 2}, {0, 6}} is stored in memory as</p>
<p>&hellip; 4 | 2 | 0 | 6 &hellip;</p>
<p>Row-major traversal aligns with spatial locality, leading to a cache miss ratio of 1/8, which can be further improved with prefetching.</p>
<p>Now, let&rsquo;s see how <strong>NOT</strong> to do it:</p>
<p>Column-major traversal:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>; j<span style="color:#f92672">&lt;</span>N; j<span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>; i<span style="color:#f92672">&lt;</span>N; i<span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>        sum <span style="color:#f92672">+=</span> a[i][j];
</span></span></code></pre></div><p>Here, the loop order is reversed. This time we do not utilize spatial locality, where elements in the same row like a[i][j+1], a[i][j+2], a[i][j+3] are loaded into the cache because, if N &gt; 8, then a[i+1][j], the next reference in our loop, will definitely not be in our cache. If N*8 exceeds the cache size, the situation is even worse, because when the outer loop jumps from j to j+1, until then a[i][j+1] will be long gone from the cache, since other array elements pushed it out from there. This results in a 100% cache miss ratio.</p>
<h3 id="traversal-with-blocks">Traversal with blocks</h3>
<p>Another technique is the so called loop tiling, where a matrix is traversed in blocks. This is useful for operations like transposing a matrix:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>; i<span style="color:#f92672">&lt;</span>N; i<span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> j<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>; j<span style="color:#f92672">&lt;</span>N; j<span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>        b[j][i] <span style="color:#f92672">=</span> a[i][j];
</span></span></code></pre></div><p>Here, a is traversed row-major, and b column-major, resulting in a 100% cache miss ratio for b for large N, as you can see the reasoning in the paragraph above. We can improve this with loop tiling:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> (bi<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>; bi<span style="color:#f92672">&lt;=</span>N<span style="color:#f92672">-</span>BLK; bi<span style="color:#f92672">+=</span>BLK)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (bj<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>; bj<span style="color:#f92672">&lt;=</span>N<span style="color:#f92672">-</span>BLK; bj<span style="color:#f92672">+=</span>BLK)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (i<span style="color:#f92672">=</span>bi; i<span style="color:#f92672">&lt;</span>bi<span style="color:#f92672">+</span>BLK; i<span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span> (j<span style="color:#f92672">=</span>bj; j<span style="color:#f92672">&lt;</span>bj<span style="color:#f92672">+</span>BLK; j<span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>                b[j][i] <span style="color:#f92672">=</span> a[i][j];
</span></span></code></pre></div><p>This may seem obfuscated, but here is a diagram to help:</p>
<p><img alt="blokkos ciklus" src="/blokkosciklus.png"></p>
<p>Choosing an appropriate block size (BLK) is crucial, as the goal is to minimize the total number of cache misses.</p>
<p>Though matrix transposition may seem as an edge case scenario, matrix operations are actually very often used, such as in GPUs which is optimized for these tasks using more advanced techniques.</p>
<h2 id="summary">Summary</h2>
<p>We have explored an important aspect of our computer, the memory hierarchy, specifically focusing on the cache. Using this knowledge, we have found solutions to practical problems that result in better performance. What more one could wish for? :D</p>
]]></content>
        </item>
        
    </channel>
</rss>
