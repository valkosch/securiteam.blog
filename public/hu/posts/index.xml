<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Posts on Kurcz Valentin</title>
        <link>http://localhost:1313/hu/posts/</link>
        <description>Recent content in Posts on Kurcz Valentin</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>hu</language>
        <copyright>&lt;a href=&#34;https://creativecommons.org/licenses/by-nc/4.0/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;CC BY-NC 4.0&lt;/a&gt;</copyright>
        <lastBuildDate>Tue, 09 Jul 2024 17:47:21 +0200</lastBuildDate>
        <atom:link href="http://localhost:1313/hu/posts/index.xml" rel="self" type="application/rss+xml" />
        
        <item>
            <title>Az Információs forradalom és az internet következményei</title>
            <link>http://localhost:1313/hu/posts/2024/07/az-inform%C3%A1ci%C3%B3s-forradalom-%C3%A9s-az-internet-k%C3%B6vetkezm%C3%A9nyei/</link>
            <pubDate>Tue, 09 Jul 2024 17:47:21 +0200</pubDate>
            
            <guid>http://localhost:1313/hu/posts/2024/07/az-inform%C3%A1ci%C3%B3s-forradalom-%C3%A9s-az-internet-k%C3%B6vetkezm%C3%A9nyei/</guid>
            <description>Az internet a világunk egyik legélesebb kétélű kardja. A kereskedelemre, ezáltal pedig a gazdaságra gyakorolt pozitív hatása megkérdőjelezhetetlen. Az viszont még mindig kérdéses, hogy a társadalom és az emberek milyen árat fizettek ezért.</description>
            <content type="html"><![CDATA[<p>Az emberi viselkedés központi eleme az információ. Mélyen belénk van kódolva az információ keresése, állandó gyűjtése, halmozása, feldolgozása és továbbítása, hiszen évezredekkel korábban a túlélést jelntette mind ez. Az információ olyan számunkra mint az oxigén. Nem véletlen hogy az ingermegvonás egy rendkívül hatékony módszere volt a kínzásnak, hiszen az agyunknak szüksége van újabb információra, máskülönben magunkra akaszhatjuk a sárgacédulát. Társadalomról is csak azért tudunk beszélni, mert megugortuk azt az evolúciós lépcsőfokot, amelyik után elkezdtünk csoportosan információt megosztani egymással. Nem kellett minden generációnak újra feltalálni a kereket, elég volt csak az idősöktől megtanulni. Az internet sem sokkal több ennél, mi is csak a modern kor ősemberei vagyunk.</p>
<h2 id="a-jó">A Jó</h2>
<p>Az interneten nincsen távolság és lassan már minden háztartásban van egy internet-képes eszköz, tehát jóformán bárkivel kapcsolatba tudunk lépni szinte azonnal, fizikai határok nélkül. Csillagászati mértékekben lehetne kifejezni az elérhető tudásanyagot is, szóval tanulni és fejlődni elméletben soha nem volt ilyen egyszerű. Arról pedig nem is kell beszélni hogy, mennyi munkát teremtett, és mekkora platformot biztosít a kereskedelemnek. <em>De hol itt a csattanó?</em></p>
<h2 id="a-rossz">A Rossz</h2>
<p>Sok eszközről el lehet mondani, hogy nagyon hasznos egészen addig amíg nem rossz szándékkal használják. Ott van például a kés, lehet vele kenyeret szeletelni, de embert is ölni. Ott a maghasadás, lehet vele lényegében tiszta, nagy mennyiségű energiát előállítani erőművekben, de ugyanakkor városokat lenullázni is. Azt már lehet szerintem látni ezek alapján is, hogy legalább akkora kárt lehet okozni a legtöbb eszközzel, mint amennyi hasznot lehet faragni belőle. Az internet is hasonló, de mégis más egy kicsit. Az internet nem csak fekete-fehér, rengeteg bújtatott következménye van aminek a kimenetelét nem tudjuk megjósolni, de már hatását érezhetjük jelenünkben is. Az emberek észre sem veszik ezeket a folyamatokat, mivel nem olyan mint egy atomvillanás vagy egy vágás, normálisnak érzik mert az interneten olyan gyökeres ösztöneink vannak kihasználva, amikről talán a legtöbben nem is hallottak. Elvesztettünk egy háborút, amiről nem is tudtuk, hogy létezik.</p>
<p>A valóság minden ember számára az amit lát, hall, tapint, szagol, ízlel, tehát az információk amik nap mint nap érnek minket. A modern ember elsődleges információforrása az internet, tehát jogosan állíthatjuk azt, hogy az internet nagyban befolyásolja valóságérzetünket, és világképünket. Na de milyen valóság is ez?</p>
<h3 id="hatása-emberi-kapcsolatainkra">Hatása emberi kapcsolatainkra</h3>
<p>Az előbb már említettem, hogy az egyik dolog, amire az internet büszke lehet az az emberek összehozása. A közösségi média pont azért lett olyan hatalmas, mert erre az embereknek szüksége van, társas lények vagyunk. Bennünk különféle hormonok, mint például az oxytocin vagy a dopamin, szabadulnak fel ha más emberekkel ismerkedünk, amik sikerélménynek az érzetét adják. Ezekről később is lesz szó. Ez viszont több sebből is vérzik.</p>
<p>Első dolog amit kiszeretnék emelni, hogy a közösségi médián senki a valóságot osztja meg magáról. Mindenki azt az alter egóját mutatja magáról aki boldog, aki sok pénzt keres, aki utazik és általánosságban csak pozitív élmények érik. Na már most ha ezt egy átlag ember meglátja és összehasonlítja középszerű életével, amiben igenis vannak szomorú és fájdalmas pillanatok, akkor el lesz keseredve mert azt fogja hinni, hogy valamit ő csinál rosszul. Pedig abban biztosak lehetünk, hogy a képernyő másik oldalán lévő embernek is vannak problémái. Ez egy nagyon általános példa volt, de többet is bele lehet látni, elég csak a testépítő influenszerekre gondolni, akik olyan normákat állítanak amik természetes módon elérhetetlenek, ezért az emberekben hamis példák tudnak kialakulni, így önkép és testképzavarba is futhatnak.</p>
<p>Az értékrendszerünkre is nyílván hatással van a közösségi média, hiszen minden amit ott teszünk, megosztunk, juttalmazva van like-okkal, más emberek elismerésével, ez pedig szintúgy sikerélményt okoz bennünk. Ennek az érzésnek a folytonos kajtatása oda vezet hogy az értékrendszerünk az lesz, hogy nem lesz értékrendszerünk, mivel minden &ldquo;jó&rdquo; ami megtekintést és like-ot hoz. Ennek a megtestesülése az influenszerek, akik pénzért és megtekintésért, bármit állítanak, bármit megtesznek. A valóság az ő szemükben az, ami éppenséggel pénzt hoz a házhoz. Óceánia mindig is háborúban állt Eurázsiával, mondta ezt egy influenszer 3 pengőért.</p>
<p>Hiába hoz össze annyi új emberrel az internet, összeségében szerintem azt lehet elmondani, hogy az emberek csak magányosabbak lettek általa. Az interneten szerzett ismerősök azt az illúziót tartják fönt, hogy több százan vesznek körül téged, de a valóságban egyikükkel sincs közös emléked, pedig azok az igazán fontosak. Szerintem a barátságok, és a párkapcsolatok is akkor virágoznak ha van úgynevezett proof-of-work, tehát minél több munkát és energiát fektetsz bele, hogy legyenek közös pillanatok a valóságban.</p>
<p>Sajnos az internet kapcsán egyre többször jön elő ez az illúzió szó. Ez azért van szerintem, mert sok olyan dolog van az interneten, ami ugyanazt az érzést, ugyanazokat a hormonokat szabadítja föl bennünk mintha a valóságban csinálnánk, de közben meg egy sokkal másodrendűbb és mesterségesebb tevékenység. Talán mondanom se kell de a pornó is ide tartozik. Teljesen átveri, átprogramozza az emberek agyát. Nulla energia befektetést igénylő, végtelen élvezet. Ez a modern ember rákfenéje. Ez végül oda vezet, hogy az emberek kedvtelenek, ambíció nélküliek és motiválatlanok az élet minden területén, hiszen a test már nem tudja őket mivel jutalmazni hiszen hormonháztartásukat kimerítették, az említett élvezetekkel. Semmi sem számít, semmi sem okoz örömöt, mert kiégette az internet az agyat. Ez pedig a hedonizmus.</p>
<p>A cyberbullying és az online grooming is egy jelentős probléma, amik főleg az emberi jellem hibájából származnak, de az internetnek mint közvetítő közegnek is van felelőssége ebben.</p>
<p>Utolsónak hagytam azt ami szerintem a legfájóbb pontja az egésznek. Azt gondolná az ember, hogy az internet párbeszédet teremt, hogy vitákat indít, mivel annyi különböző gondolkodású, származású, anyagi helyzetű embert ereszt össze, hogy a súrlódást lehetetlen elkerülni. A helyzet viszont merően eltér ettől. A baj ott kezdődik, hogy a profitorientált cégek, nem meglepő módon, a profitot szeretnék maximalizálni (wow), és  ezt úgy érik el, hogy maximalizálják az applikáción eltőltött idődet. Ennek egyik módja az, hogy olyan tartalmat raknak eléd ami érdekel téged, de legfőképp olyat ami <strong>tetszik</strong> neked. A háttérben müködő tanuló algoritmusok annyira tökéletesek és annyira olajozottan müködnek, hogy nagyon gyorsan világossá válik számukra milyen skatulyákba lehet téged sorolni. Nem fogsz látni olyan véleményeket, amik ellentmondanak a tieddel. Ha kutyás ember vagy kutyákat fogsz látni. Nincsen párbeszéd, nincsen vita, nincsen haladás. Mi követlezik ebből? Egy olyan túlhigénikus világ épül fel benned, ahol mindenki egyetért veled. Ez viszont nem a valóság. A valóságban, igenis sok különböző vélemény van és gondolat, amiknek meg kell ütközniük egymással. Egy elv, egy elmélet akkor ér valamit, ha próbára teszik azt. Legvégül pedig azon elvek maradnak fent, amik a legerősebbek voltak, legalaposabbak és legindokoltabbak. Mi történik amikor ez nincs jelen, mint például az interneten? Olyan elméletek kapnak lángra amiknek a valóságban esélyük se lenne, gondolok én itt a Lapos Föld hívőkre, vagy egyéb más áltudományt valló csoportokra. Buborékok jönnek létre az interneten, amik között nincsen átjárás, elmondod a véleményedet és csak a saját visszhangodat hallod visza. Az internet tehát amennyire összeköt minket, annyira szakadékot is teremt köztünk. Ennek a következményeiért pedig nem kell messzire tekinteni: a 2020-as amerikai választások után polgárháborús helyzet alakult ki, mivel a vesztes republikánus párt követői csalással vádolták a liberálisokat. Nem meglepő ez sem, csak gondoljunk bele egy republikánus szavazó helyzetébe, Facebookon csak republikánus csoportokban volt benne, csak az ő általa támogatott jelölteknek a hirdetését látta stb.. Ez után megnyerte egy olyan jelölt egy olyan párttal a választást ami az ő világában eddig nem is létezett.</p>
<p>Egyén szintjén is érdemes megvizsgálni mindezt, hiszen minket, mint egyéneket mégis csak jobban érint. Az emberek személyiségére szerintem negatív hatással van ez a &ldquo;for you&rdquo; marketing fogás, mivel az emberek így abban szocializálódnak, hogy minden róluk szól, minden nekik szól. <em>&ldquo;Ez a termék csak neked!&rdquo;</em> Mondanom sem kell, hogy ez egy eléggé egocentrikus jellemet tud okozni, ami hisztérikus rohamot kap, abban a pillanatban, hogy valaki más véleményen van mint ő. Eddig amikor azt mondtam hogy &ldquo;vélemény&rdquo;, mindig a kúltúrális és tiszteletteljes véleményekre gondoltam, de mivan akkor az alpári mocskolódással és trollkodással amivel az internet is tele van. A legjobb megoldás az lenne, ha az emberek megtanulnának a másikkal empatikusan viselkedni és normális formába önteni véleményüket. Az viszont szerintem megengedhetetlen, hogy csak egyszerűen cenzúrázzuk a bántó hozzászólásokat. Ezzel nem szüntettük meg a problémát csak a szőnyeg alá söpörtük csak azért hogy az illúziót fenntarthassuk. Ki mondja meg akkor mi a bántó komment, a kormány? Lehet ma még nem, de holnap már a szeletelt kenyér kifejezés már bántónak számít, csak mert valakinek ez áll az érdekében. Az emberekben igenis ki kell alakulni egy immunitásnak, toleranciának a negatív élmények ellen is, mivel sajnos a valóság tele van velük. Mindeközben pedig arra kell törekedni, hogy a tudatlanságot, ami a troll hozzáállást okozta, megszüntessük. A hajléktalanság sem szűnik meg, csak annyival hogy betiltjuk a hajléktalanokat. A tanúlság az, hogy több forrásból kell midnig tájékozódnunk és törekedünk kell egymás megismerésére, megértésére még akkor is ha úgy gondoljuk nekünk van igazunk, mert a világ nem fekete-fehér és mert közösen sokkal többre mehetünk, hiszen magányos hősök nem léteznek.</p>
<p><img alt="Öngyilkosságok száma" src="/suiciderates.png"></p>
<p>Ez a kép 100.000 emberre jutó öngyilkosságok számát mutatja az Egysült Államokban az évek múltával. Persze nem lehet közvetlen következtetést vonni a kép adata és az említett internet problémái között, hiszen jó pár, nem független tényező játszik szerepet még, de azért mindenesetre egy eléggé elszomorító görbe.</p>
<h3 id="hatása-kognitív-képességeinkre">Hatása kognitív képességeinkre</h3>
<p>Azt is felhoztam mint jótékony dolog, hogy milyen nagy mennyiségű tudás áll rendelkezésünkre az internet miatt. Ez így is van, csak éppenséggel az internetről informálódni olyan, mint tűzcsapból vizet inni. Egyszerűen az agyunk nem képes egészséges keretek között ennyi információt befogadni, és ennek vannak következményei.</p>
<p>Mindenekelőtt fontos belátni, hogy amennyire könnyű igazságot terjeszteni annyira egyszerű dezinformálni is az interneten. Társadalmakat, csoportokat lehet ezzel megtéveszteni, irányítani, megdönteni. A valóságot a legtöbb ember amúgy is az interneten, a hírportálokon keresztül látja, így a manipuláció és megvezetés gyerekjáték. Csak elégszer kell mondani hogy a fű az kék, az ég pedig zöld, előállítani a saját forrásainkat, az ellenvéleményeket pedig túlkiabálni. Az internet a tökéletes eszköz a propaganda terjesztésére, mindenkit el lehet érni vele, nem erőforrás igényes, az emberek szánt szándékkal nézik, és a megfelelő algoritmusokkal a kritikus hangokat el lehet izolálni a hívőktől, a kemény magtól. Még szerencse, hogy az interneten senkinek sem áll szándékában a tömegek manipulációja :DD.</p>
<p>Azt hogy milyen hatással volt / van az internet az agyunkra, talán a fiatal generációkon lehet a legjóbban megfigyelni, mivel fiatal korban alakul ki az idegpályák nagy része, így a változásra is ekkor alkalmas a legjobban az agy. A probléma az információ mennyiségével és a formájával van legfőképp.</p>
<p>Mennyiség terén azt tudni kell, hogy az internet mérete 2 évente duplázódik és exponenciálisan növekszik. Amikor ez a rengeteg információ és inger elér minket, az agyunk úgy védekezik, hogy egyszerűen már nem fogadja be őket. Olvasol, nézel valamit de már 30 perc múlva nem is emlékszel rá, máskülönben az agy elvérezne a sok ingertől. Illetve a nagy mennyiségű információ, megosztja a figyelmünket, soha nem fogunk tudni egy dologra koncentrálni. Mindenbe belekezdünk de semmit nem fejezünk be, mert addigra már a másik információn jár az agyunk. Ez a biztos útja annak, hogy a tudásunk felületes legyen és haszontalan. Az egész emberiség tudása rendelkezésünkre áll, de nem tudunk vele mit kezdeni.</p>
<p>Az információnak sok formája van, de amit szerintem most érdemes szemügyre venni az a short content. Ahogy már szó volt róla, az információ szerzés olyan nekünk mint a drog. A rövid tartalmak, pedig tökéletesen beleillenek az egyre gyorsuló világunkba, hiszen alig igényelnek időt, és élvezettel csináljuk őket. Mindig többet és többet akarunk belőlük egészen addig, amíg az agyunkban a receptorok már ropogósra sűltek a sok inger miatt. Ráadásul olyan dolgokat látunk amik tetszenek nekünk és kifogyhatatlan mennyiségben. Meggyőződésem, hogy a legtöbb ilyen applikáció mögött (TikTok, Instagram, Facebook pl) több pszichológus dolgozik mint programozó, mivel lenyűgöző módon tartják csapdában figyelmünket különféle ösztöneinket kihasználva. Mert a végső cél ez, hogy minél többet odaadjunk magunkból nekik, mivel mi vagyunk a termékek, mi vagyunk akik figyelmét, adatait eladják. Ha nem fizetsz a termékért, akkor te vagy a termék. Ebben nem mi vagyunk a hibásak, a döntés már nem tudatosan történik a legtöbb embernél, hanem reflexből nyúl a telefonhoz például. Abban viszont nagyon is hibásak vagyunk ha gyerekeinket nem védjük meg ettől, miután már tisztában vagyunk a következményekkel. Egyre gyakoribb sajnos az &ldquo;iPad kid&rdquo; jelenség, ahol a szűlő fáradtság vagy egyéb okok miatt, hanyag módon letudja a gyerek lefoglalását azzal, hogy kezébe adja a tabletet. Biztos nem sülhet ki semmi rossz, ha egy kisgyereknek korlátlan hozzáférése van az egész internethez&hellip;</p>
<p>Csak hogy konkrétumokat is említsek, a koncetrálóképesség drasztikusan csökken short content huzamos fogyasztása után. Az agyunk mindig alkalmazkodik a körülményekhez, és ha mi mindig maximum 1 perces tartalmakat fogyasztunk, akkor egyszerűen átprogramozza magát az agy és egy könyv elolvasása már nem fogja tudni lekötni a figyelmünket. Nem csak a könyvektől esünk el így, de minden mástól is ami egy kicsit is hosszabb gondolatmenetet igényel. Ha már könyveket megemlítettem, érdemes azt is leszögezni, hogy az interneten fogyasztott tartalom egyre nagyobb része vizuális. Ez talán azért hátrányos, mert így a kreativitásunkat soha nem kell megmozgatni, hogy elképzeljünk valamit, hiszen már ott van készen előttünk.</p>
<h2 id="és-a-csúf">És a Csúf</h2>
<p>Az internet bármennyire is egy csodálatos és utópisztikus elképzelés volt, jelen pillanatban a tömegek kihasználásáról, szárazra fejéséről szól, ahol az emberek már nem gyártanak semmi valódi értéket, csupán fogyasztók. Minden azzal keződik, hogy reggel felkelsz az álmodból. Itt az ideje felkelni, felkelni az álómból, a kényelemből és szembenézni a valósággal, ami lehet csúf vagy reménytelen, sárga és keserű, de legalább a miénk. Használd az internetet, de ne az internet használjon téged.</p>
<p>Remélem sikerült jól összefoglalnom ezt a pár gondolatomat a témában, ha van bármi hozzászólásod ne tartsd magadban! Legyen szép napod!</p>
]]></content>
        </item>
        
        <item>
            <title>Lokalitástudatos programozás</title>
            <link>http://localhost:1313/hu/posts/2024/06/lokalit%C3%A1studatos-programoz%C3%A1s/</link>
            <pubDate>Fri, 28 Jun 2024 13:20:06 +0200</pubDate>
            
            <guid>http://localhost:1313/hu/posts/2024/06/lokalit%C3%A1studatos-programoz%C3%A1s/</guid>
            <description>Egyáltalán nem mindegy, hogy egy mátrixot, oszloponként, vagy soronkét, nehogy Isten véletlenszerűen járjuk be. Ebben a cikkben körüljárjuk, hogy hogyan lehet számítógépes ismereteinket igába hajtani, a programunk előnyére.</description>
            <content type="html"><![CDATA[<p>Neumann architektúrája óta, egy számítógép müködése során, a futtatandó utasításokat, és ezen utasítások által hivatkozott címek tartalmát is egy memóriában tárolja. A programban használt adatok, úgynevezett adatmemóriból érhetőek el, ez pedig tárhierarchiába rendeződik.</p>
<h2 id="tárhierarchia">Tárhierarchia</h2>
<p>A számítógépünk teljesítménye lényegében a processzor és a memória órajeléből tevődik össze, és eme két egység közül, a memória az ami a processzor mögött kullog. Ez azt jelenti, hogy hiába a magas CPU órajel, ha a memória szűk keresztmetszetként viselkedik mellette, mivel ha az éppen végrehajtandó utasításnál, nincsen kéznél a használandó adat, akkor a processzor várakozásra kényszerűl, ezáltal nem használja ki teljes potenciálját, így suboptimális lesz a kihasználtsága.</p>
<h3 id="lokalitási-elvek">Lokalitási elvek</h3>
<p>Nagy <em>szerencse</em> hogy a számítógépes programok többsége valamilyen mintát követnek, mikor a memóriába nyúlnak, úgynevezett <strong>lokalitási elveket</strong>, és ezeket kihasználva tudunk a teljesítményen javítani. Többféle lokalitási elvet is ismerünk:</p>
<p>Ha egy memóriában tárolt adaton műveletet végeztünk&hellip;</p>
<ul>
<li><em><strong>Időbeli lokalitás:</strong></em> &hellip;akkor valószínüleg a közel jövőben is használni fogjuk. Példa: egy ciklus számlálóját minden ciklusban növelem.</li>
<li><em><strong>Térbeli lokalitás:</strong></em> &hellip;akkor valószínüleg a közelben lévő adatokat is használni fogjuk. Példa: egy tömböt bejárok.</li>
<li><em><strong>Algoritmikus lokalitás:</strong></em> Sok program dinamikus adatstruktúrákkal dolgozik (pl. bináris fák, láncolt listák), ezek viszont nem felelnek meg se nem a térbeli se nem az időbeli lokalitásnak (mivel a memóriában nem folytonosan helyezkednek el), ámde mégis szabályos viselkedést eredményeznek, melyet ki lehet használni.</li>
</ul>
<p>Tehát ha lokalitási elvek szerint, a processzor közelébe helyezzük a gyakran használt adatokat és környezetüket, akkor csökkenthetjük a lassú és költséges memória műveletek számát. Ekkor is memóriában helyezzük el az adatainkat, csak egy sokkal gyorsabb de kisebb és magasabb fogyasztásúban. Ezt a memóriát cache memóriának nevezzük. De milyen technológiát használnak cachenél?</p>
<p>Több memória technológiát is ismerünk, mint például a magas adatsűrűségű és olcsóbb, de lasúbb DRAM, vagy az alacsony adatsűrűségű és drága, de gyors SRAM. Egy bit tárolásához, A DRAM 1 tranzisztort, az SRAM pedig 6-ot használ, innen ered a fogyasztás, adatsűrűség és az ár különbség. Egyiknél sem teljesülhet viszont egyszerre az, hogy olcsó, gyors és nagy, így mindig az igényekhez igazítva, a kompromisszum kötés elkerülhetetlen. Itt jön be a tárhierarchia miszerint több szintből építjük fel a memóriát úgy, hogy az adott szintet minél többször használja a processzor, annál gyorsabb és ezáltal kisebb legyen.</p>
<p><img alt="tárhierarchia" src="/tarhierarchia.png"></p>
<p>A leglassabb tárolón, a háttértáron tartjuk a legkevésbé használt, de nagy mennyiségű adatokat, általában HDD-n vagy SSD-n. A gyakran használt adatokat az operatív memóriában tároljuk, általában DRAM-ot használva, és az éppen futó program vagy process által használt adatokat (pl. egy lokális  változót) pedig a cache-ben tartjuk, ami SRAM-ból épül fel.</p>
<blockquote>
<p>A cache további müködését itt nem részletezem, de ha érdekel akkor érdemes utánanézni, hogy mi alapján kerülnek be a cache-be az adatok, mert nyílván mikor a program hivatkozik a memóriára akkor már készen kell állnia a cache-ben, így valahogy meg kellene jósolni, hogy a jövőben használni fogjuk-e az adatot, ugyanakkor nem szemetelhetjük tele a cache-t mindennel mert kicsi :(, ezért jó tippnek kell lennie. Prefetch-nek nevezik ezt, és egyszerűbb mind aminek gondolnád.</p>
</blockquote>
<p>Mind ezek szerint elengedhetetlen, hogy a processzor kihasználás érdekében, a programozó segítse a tárhierarchia munkáját:</p>
<ul>
<li>A cache esetében, ha a programozó össze-vissza hivatkozik a memóriára, akkor sok lesz a cache hiba, és így kénytelen lesz a számítógép a lomha memóriához nyúlni.</li>
<li>A DRAM alapú rendszermemória esetében az azonos sorban lévő cellák elérése gyors, de ha itt is véletlenszerűen hivatkozunk a címekre, akkor az új sorok megnyitása költésges és lassú művelet lesz.</li>
</ul>
<p><strong>Tehát a programozó célja, hogy a memóriákat úgy címezze, hogy azok megfeleljenek a lokalitási elveknek. Hogyan?</strong></p>
<h2 id="lokalitásbarát-ciklusszervezés">Lokalitásbarát ciklusszervezés</h2>
<p>A gyakorlatban számtalan alkalommal van szükség egy-, vagy többdimenziós tömbök bejárása, ehhez pedig ciklus(ok) szükséges(ek). Példát mutatok azon ciklusszervezési technikákra, melyek hasznosítják az imént kifejtett tárhierarchiai ismereteinket, és ezzel javítják programunk futásidejét.</p>
<h3 id="ciklusegyesítés">Ciklusegyesítés</h3>
<p>Eredeti kód:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> N; i<span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>    b[i] <span style="color:#f92672">=</span> c <span style="color:#f92672">*</span> a[i] <span style="color:#f92672">-</span> x;
</span></span><span style="display:flex;"><span>sum <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> N; i<span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>    sum <span style="color:#f92672">+=</span> b[i];
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span>( <span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> N; i<span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>    d[i] <span style="color:#f92672">=</span> a[i] <span style="color:#f92672">+</span> b[i];
</span></span></code></pre></div><p>Fenti kód egy C nyelvű mezei, iskolapélda kód. Most mindenki kapaszkodjon meg mert matekozni fogunk. Számoljuk ki a cache hiba-arányt azaz azt, hogy összes cache-hez intézett kérésünk közül mennyiszer kaptuk azt a választ, hogy sajnos a lassú memóriához kell nyúlnunk, merta cache-ben nincsen benne az, amit keresünk. Tegyük fel az alábbiakat az egyszerűség kedvéért:</p>
<ul>
<li>N legyen a tömb mérete tetszőlegesen nagy</li>
<li>a cache blokk mérete 64 bájt</li>
<li>a tömb elemei 8 bájtos double-ök</li>
<li>az i, c, x és sum elérése nem jár memória-hozzáféréssel.</li>
</ul>
<p>Az első for ciklus bejárja az a és b tömböt. Az i = 0 -nál cache hibát kaptunk a[0] és b[0] esetben is, mivel üres volt eddig még a cache-ünk. Ha cache hiba történik akkor viszont 8 tömb elem kerül be a cachebe, mivel a térbeli lokalitás szerint azt feltételezzük, hogy a soron következő elemeket is használni fogjuk, és több már nem is férne bele egy cache blokkba (64/8=8). Tehát 8 lépésenkét lesz cache hiba, és mivel 2N memóriahivatkozás van ezért itt 2N/8 cache hiba lesz.</p>
<p>A második for ciklusnál, ha N elég nagy volt akkor a b tömb eleje már nincs benne a cache-ben, mert a hátsó elemei már kiszórították onnan. Ezért itt, megint minden 8. hivatkozás cache hiba lesz, így N/8 hibát okozva.</p>
<p>Hasonlóan számolhatunk a harmadik ciklusban is, 3N hivatkozás függvényében 3N/8 cache hibát kapunk.</p>
<p>Szummázva a cache hibákat megkapjuk, hogy 6N memóriahivatkozásnál 1/8 lesz a cache-hiba arány, ami 12.5%.</p>
<p>Most pedig ciklusegyesítéssel a kód:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span>sum <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>; i<span style="color:#f92672">&lt;</span>N; i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>    b[i] <span style="color:#f92672">=</span> c <span style="color:#f92672">*</span> a[i] <span style="color:#f92672">+</span> x;
</span></span><span style="display:flex;"><span>    sum <span style="color:#f92672">+=</span> b[i];
</span></span><span style="display:flex;"><span>    d[i] <span style="color:#f92672">=</span> a[i] <span style="color:#f92672">+</span> b[i];
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Egyértelműen látszik, hogy ez az algoritmus ugyanazzal a funkcionalitással rendelkezik mind az eredeti, csak kicsit jobb. A ciklus hasában az első 2 memóriahivatkozás még mindig minden 8. lépésnél cache hibát okoz. A második sorban az a[i] és b[i] soha nem okozhat cache hibát, mivel már biztosan a cache-ben vannak az első sor révén. A harmadik sorban pedig az előző érvelés alapján csak a d[i] fog cache hibát dobni 8 lépésenként.</p>
<p>Tehát összesen 3N/8 (= 2N/8 + N/8) hibát kapunk így az arány 6N memóriahivatkozás mellett 1/16-od, ami 6.25%, azaz fele az előzőnek.</p>
<p>Itt látszik, hogy milyen kis energia befektetéssel, kétszer gyorsabb futásidőt kaptunk. Az első ökölszabály tehát, hogy amit lehet egyetlen ciklusban, azt egyetlen ciklusban érdemes megvalósítani.</p>
<h3 id="ciklusok-sorrendjének-optimalizálása">Ciklusok sorrendjének optimalizálása</h3>
<p>Az alábbi példában egy 2 dimenziós tömb, 2 különböző bejárásán mutatom meg, miért fontos a ciklusok sorrende.</p>
<p>Most először a jó példát mutatom</p>
<p>Bejárás sor-folytonosan:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>; i<span style="color:#f92672">&lt;</span>N; i<span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> j<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>; j<span style="color:#f92672">&lt;</span>N; j<span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>        sum <span style="color:#f92672">+=</span> a[i][j];
</span></span></code></pre></div><p>A cache hiba vizsgálása előtt tisztázni kell, hogy C nyelv a 2 dimenziós tömböket sor-folytonosan helyezi el a memóriában. Tehát ha van egy {{4, 2}, {0, 6}} 2 dimenziós tömb akkor az a memóriában</p>
<p>&hellip; 4 | 2 | 0 | 6 &hellip;.. módon kap helyet</p>
<p>Ekkor a bejárás soronként megy végig. Ez szerencsés hiszen a térbeli lokalitás miatt sorokat fog a számítógép is a cache-be rakni. Így a feljebb kikötött feltevések és 64 bájtos blokkméret, 8 bájtos elemméret mellett az algoritmus cache hiba-aránya 1/8-ad lesz, de prefetch algoritmussal még ezen is lehetne javítani.</p>
<p>Most nézzük meg, hogyan <strong>NE</strong> csináljuk</p>
<p>Bejárás oszlop-folytonosan:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>; j<span style="color:#f92672">&lt;</span>N; j<span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>; i<span style="color:#f92672">&lt;</span>N; i<span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>        sum <span style="color:#f92672">+=</span> a[i][j];
</span></span></code></pre></div><p>Itt felcseréltem a két ciklus sorrendjét. Ilyenkor hiába próbálja az egy sorban lévő elemeket (pl. a a[i][j+1], a[i][j+2], a[i][j+3] &hellip;) betölteni a számítógép, mert ha N &gt; 8, akkor a[i][j] után következő a[i+1][j] nem lesz benne a cache-ben biztosan. Ha N*8 nagyobb mint a cache méret akkor még ennél is rosszabb a helyzet, mivel mire a külső ciklus lép egyet j-ből j+1-be addigra a[i][j+1] már nem lesz benne a cache-ben, hiába olvastuk be a[i][j]-nél. Tehát minden memóriahivatkozás cache hibát dob, azaz 100% az arány.</p>
<h3 id="blokkos-ciklusszervezés">Blokkos ciklusszervezés</h3>
<p>Van még egy további technika, az úgynevezett blokkos ciklusszervezés, amikor is blokkonként járunk be egy mátrixot. Ez például akkor tud nagy segítséget nyújtani, amikor egy mátrixot kell transzponálni:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>; i<span style="color:#f92672">&lt;</span>N; i<span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> j<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>; j<span style="color:#f92672">&lt;</span>N; j<span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>        b[j][i] <span style="color:#f92672">=</span> a[i][j];
</span></span></code></pre></div><p>Ekkor a-t sor-folytonosan b-t oszlop-folytonosan járjuk be, ezért a fenti példák alapján, elég nagy N esetén, b-nél 100% os lesz a cache hiba-arány. Ezen tudunk segíteni az alábbi módon:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#66d9ef">for</span> (bi<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>; bi<span style="color:#f92672">&lt;=</span>N<span style="color:#f92672">-</span>BLK; bi<span style="color:#f92672">+=</span>BLK)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (bj<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>; bj<span style="color:#f92672">&lt;=</span>N<span style="color:#f92672">-</span>BLK; bj<span style="color:#f92672">+=</span>BLK)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (i<span style="color:#f92672">=</span>bi; i<span style="color:#f92672">&lt;</span>bi<span style="color:#f92672">+</span>BLK; i<span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span> (j<span style="color:#f92672">=</span>bj; j<span style="color:#f92672">&lt;</span>bj<span style="color:#f92672">+</span>BLK; j<span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>                b[j][i] <span style="color:#f92672">=</span> a[i][j];
</span></span></code></pre></div><p>Kicsit obfuszkáltnak tűnhet, de talán az ábra segít</p>
<p><img alt="blokkos ciklus" src="/blokkosciklus.png"></p>
<p>Itt csak arra kell figyelni, hogy megfelelő BLK-t, azaz blokkméretet válasszunk, mivel az egésznek az a lényege, hogy akkora blokkot válasszunk, hogy minél kevesebbszer legyen cache hiba szummázva.</p>
<p>Kicsit edge-case-nek tűnhet ez az egész mátrix transzponálás, de a gyakorlatban rengeteg mátrix transzponálás és mátrix művelet történik, elég csak a grafikus kártyátokra nézni, ami pontosan erre van optimalizálva, a fenti technikáknál jóval bonyolúltabb módszerekkel is.</p>
<h2 id="összegzés">Összegzés</h2>
<p>Tehát megismerkedtünk a számítógépünk egy fontos elemével a tárhierarchiával, azon belül is szemügyre vettük jobban a cache-t, majd pedig ezt a tudást felhasználva gyakorlati problémákra tudtunk jobb teljesítményt eredményező megoldásokat találni. Kell ennél több? :D</p>
]]></content>
        </item>
        
    </channel>
</rss>
